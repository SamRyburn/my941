<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<recordset table="ScriptLibrary">
  <record id="name=&quot;PDCodeMigration&quot;" recordid="PDCodeMigration">
    <name type="string">PDCodeMigration</name>
    <script type="string">/**
 * We have 2 options
 * opt#1. Keep customer invest and remove PD OOB
 * opt#2. Keep both customer invest and PD OOB
 */
var OPT1 = "opt1";
var OPT2 = "opt2";
var OPTION = OPT2;

var UPGRADE_PREFIX = lib.upgradeConstants.NEW_PREFIX();

var FIRST_PHASE_X = 40;
var PHASE_SPACING = 220;
var FIRST_PHASE_Y = 50;

var $ = lib.c.$;
var _ = lib.Underscore.require();
var _str = _.str;

var _val = system.functions.val;
var _parse = system.functions.parse;
var addMigrationPatchRecord = lib.PDCodeMigrationUtil.addMigrationPatchRecord;
var PD_CODE_MIGRATION_DISABLE_SUFFIX = "_disabled";
var PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX = " codeless";
var PD_CODE_MIGRATION_WF_PREFIX = "Migrated ";
var PD_ENABLEMENT_DISABLE_SUFFIX = "_disabled_by_PDHD";
var PD_ENABLEMENT_DISABLE_SUFFIX_REQ = "_disabled_by_PDRM";
var PD_ENABLEMENT_DISABLE_SUFFIX_CHG = "_bak_by_PD";
var PD_ENABLEMENT_TOBE_USED_SUFFIX = "_for_pd4_tobe_used";

var AUTO_UPGRADED_SUFFIX_IN_DESC = " - Automatically Upgraded.";

var MIGRATE_PROFILE_SUFFIX = "_migrated";

var PHASE_NAME_LOGGING = "Logging";
var PHASE_NAME_INPROGRESS = "In Progress";
var PHASE_NAME_CLOSURE = "Closure";
var LEVEL1_INDENT=" ";
var LEVEL2_INDENT="    ";
var LEVEL3_INDENT="      ";

// the object names which needs to be migrated as normal approach,
// e.g.:"probsummary", "incidents", "rootcause", "rootcausetask"
// "cm3r", "cm3t"
var OBJECT_NAMES = ["probsummary", "incidents"];
var INCIDENT_OBJECT_NAMES = ["probsummary"];
var SERVICEDESK_OBJECT_NAMES = ["incidents"];

// the object names for request module
var REQUEST_OBJECT_NAMES = ["ocmq", "ocmo", "ocml"];
var REQUEST_DATADICT_MAPTO_AREA = {
    "ocmq": null,
    "ocmo": null,
    "ocml": null,
    "ocmqcat":"Legacy Request Management Configuration",
    "ocmocat":"Legacy Request Management Configuration",
    "ocmlcat":"Legacy Request Management Configuration"
};

var areaTableMap = {
  "Quote":"ocmq",
  "Order":"ocmo",
  "Line Item":"ocml"
  };

// TODO, to add more fields in legacy profile "ocmprofile"
REQUEST_PROFILE_MAPPED_FIELDS = ["manager.group", "require.password", "groups", "approval.groups", "allowedStatus", "audit", "calcrsk", "new.category", "new.phase"];

var copycurrent = system.functions.copycurrent;

var IS_UPGRADE_FROM_PD3_UPGHISTORY = isUpgradeFromPD3();

var SUMMARY_REPORT_OBJS = []; // array of {title:xxx, needManualCheck:true/false, files:[f1, f2]}


var TURE_CONDITION_XML = '&lt;XmlCondition&gt;&lt;collection logical="" negate=""&gt;&lt;condition logical="" negate="false"&gt;&lt;operand type="expression"&gt;&lt;Expression caption=""&gt;"true"&lt;/Expression&gt;&lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;';
var TURE_CONDITION_DESC = "( Expression: true)";

/**
 * This is the main function of this migration tool.
 * This migration tool is used to easily migrate your SM system to PD by continuely
 * using the legacy tech (for e.g., format ctrl) and still keep your previous invest
 * -- run SM with hybrid mode.
 * Be noted, this tool should be run after you upgrade to SM940 and enable PD.
 *
 * @author Ma, Xiong-jie
 */
/*
function migrate() {
    //1. rollback Object from disabled one
    migrateObjectsForNormal();
    migrateObjectsForRequestModule();

    //2. create default Workflows
    //2.0 clean PD OOB existing workflows, we do not need it for option#2, even we maybe not need it for option#1.
    //cleanOOBWorkflows();
    //2.1 create default Workflow for Incident/ServiceDesk module
    createWorkflowsByCategories();
    //2.2 create default workflow for service desk module
    // TODO, ...
    //2.3 create default Workflow for problem/knownerror module
    // TODO, ...

    //3. migrate category/subcategory/area
    //3.1 for Incident/ServiceDesk modules
    migrateCategories();
    //4. rollback search configure to change back the search format to use legacy the format

    //5. change back some of the inbox record if we need to separate problem and known error
    //6. use legacy search form
    //migrateSearchConfigs();

    //7. status problem, PD enablement adds some items into ModuleStatus table, need to rollback???
    //   or the add operation should remove from enablement tool and let customer to select to merge in migration tool?

    //8. restore legacy restore menu (keep legacy and PD OOB reqeust run in parallel approach)
    restoreLegacyRequestMenu();
    
    //9. add triggers to related PD category tables to sync the PD category data back to the legacy category table if user check the sync category back option
    if(vars["$sync.category.back"]=="true"){
        synCategoryData();
    }    
}
*/

function migrateByModules() {
    //0. set trigger and counter on/off
    // 0.1 trigger off as this migration tool will be invoked by upgrade tool, upgrade tool will make trigger off
    var ret = 0;
    system.functions.rtecall("trigger", ret, 0);
    // 0.2 counter on otherwise create workflow etc will fail with empty key.
    system.functions.rtecall("counter", ret, 1);


    //1. migrate Incident module
    migrateIncidentModule();
    //2. migrate ServieDesk module
    migrateServiceDeskModule();
    //3. migrate the built-in Processes to make sure the workflow Rule sets working
    var radNames = ["im.save.problem", "im.save", "im.close", "cc.save", "cc.qopensave"];
    migrateBuiltinProcesses(radNames);
    //3. request module
    //migrateRequestModule();
    //4. change module if it is upgrade from non-PD
    if(!IS_UPGRADE_FROM_PD3_UPGHISTORY) { // we only support the upgrade from PD3 and non-PD, if it is not from PD3, then it should be from non-PD
    	migrateChangeModule();
    }

    //5. detect uncompatible areas
    detectUncompactibleCodes();

    //6. add triggers to related PD category tables to sync the PD category data back to the legacy category table if user check the sync category back option
    if(vars["$sync.category.back"] == "true"){
        synCategoryData();
    }
    
    //7. QCCR1E127135, delete the non-use ModuleStatus for Problem Module
    lib.ProcessDesignHelpDeskEnableManager.removeModuleStatus();

    
    //x-1. generate report string which no-need manual check
    var date = new Date();
    lib.ddmEventUtil.sortObjects(SUMMARY_REPORT_OBJS, "category desc");
    
    printIt("Following is the PD code migration report which is for your information:");
    vars["$pd.wapper.migration.report"] = "Process Designer Migration Report \n\n";
    vars["$pd.wapper.migration.report"]+="Completed Migration Tasks \n";
    vars["$pd.wapper.migration.report"] = vars["$pd.wapper.migration.report"] + date.toString() + "\n";
    var category=""; 
    var i,j;
    
    for(i=0, len=SUMMARY_REPORT_OBJS.length; i&lt;len; i++) {
        if(SUMMARY_REPORT_OBJS[i].needManualCheck === true) {
            continue;
        }
        if(i==0 || (i&gt;0 &amp;&amp; category !== SUMMARY_REPORT_OBJS[i].category)){
           vars["$pd.wapper.migration.report"]=vars["$pd.wapper.migration.report"]+LEVEL1_INDENT+SUMMARY_REPORT_OBJS[i].category+" Records Related Changes\n";
           category = SUMMARY_REPORT_OBJS[i].category;
        }
        var files = SUMMARY_REPORT_OBJS[i].files;
        if(null==files || files.length===0) {
            vars["$pd.wapper.migration.report"] += "\n";
            printIt("");
            continue;
        }else {
            vars["$pd.wapper.migration.report"] = vars["$pd.wapper.migration.report"]+LEVEL2_INDENT + SUMMARY_REPORT_OBJS[i].title + "\n";
            printIt(SUMMARY_REPORT_OBJS[i].title);
           
        }
        for(j=0, lenJ=files.length; j&lt;lenJ; j++) {
            vars["$pd.wapper.migration.report"] += LEVEL3_INDENT + files[j] + "\n";
            printIt(LEVEL2_INDENT + files[j]);
        }
        vars["$pd.wapper.migration.report"] += "\n";
        printIt("");
    }
    
    writePDMigrationLog(vars["$pd.wapper.migration.report"]);
    writePDMigrationLog("===========================================================================================================================================================================\n");
    writePDMigrationLog("The Next Step\n");
    
    
    //x-2. generate report string which need manual check
    printIt("Following is the Process Designer code migration report which needs your manual review:");
    vars["$pd.wapper.migration.report.manual"] = "To successfully complete the migration process, review and validate the following records.\n";
    for(i=0, len=SUMMARY_REPORT_OBJS.length; i&lt;len; i++) {
        if(SUMMARY_REPORT_OBJS[i].needManualCheck !== true) {
            continue;
        }  
        
        if(i==0 || (i&gt;0 &amp;&amp; category !== SUMMARY_REPORT_OBJS[i].category)){
           vars["$pd.wapper.migration.report.manual"]=vars["$pd.wapper.migration.report.manual"]+LEVEL1_INDENT+ SUMMARY_REPORT_OBJS[i].category+" Records Related Changes\n";
           category = SUMMARY_REPORT_OBJS[i].category;
        }      
        
        var files = SUMMARY_REPORT_OBJS[i].files;
        if(null==files || files.length===0) {
            vars["$pd.wapper.migration.report.manual"] += "\n";
            printIt("");
            continue;
        }else {
            vars["$pd.wapper.migration.report.manual"] =vars["$pd.wapper.migration.report.manual"]+LEVEL2_INDENT + SUMMARY_REPORT_OBJS[i].title + "\n";
            printIt(SUMMARY_REPORT_OBJS[i].title);       
        }
       
        for(j=0, lenJ=files.length; j&lt;lenJ; j++) {
            vars["$pd.wapper.migration.report.manual"] += LEVEL3_INDENT + files[j] + "\n";
            printIt(LEVEL2_INDENT + files[j]);
        }
        vars["$pd.wapper.migration.report.manual"] += "\n";
        printIt("");
    }
    
    writePDMigrationLog(vars["$pd.wapper.migration.report.manual"]);

    //add pmdPatch record for message generated for workflow
    addMsgPDMpatch();

    //x. turn trigger back, how can I know the original value is on or off? - no, RTE does not provide such method
    //system.functions.rtecall("trigger", ret, 1);
    // x.2 counter off because in SM upgrade process it should be off.
    system.functions.rtecall("counter", ret, 0);
}

function writePDMigrationLog(log){
  var PDMIGRATION_LOG_PATH = "../logs/pdmigration.log";
  writeFile(PDMIGRATION_LOG_PATH, 'a', log);
}


function migrateIncidentModule() {
    //1. objects
    if(migrateObjects(INCIDENT_OBJECT_NAMES)==false) {
        printIt("Migration Incident Object fail, ignore migrating Incident Module!", true);
        return;
    }
    //2. workflow
    createIncidentWorkflowsByCategories();
    //3. migrate Incident and ServiceDesk categories
    migrateIncidentCategories();
    //4. migrate security if it is upgraded from PD3, ignore if it is upgraded from non-PD
    migrateIncidentSecurity();
    //5. migrate solution matching
    migrateIncidentSolutionMatching();
    //6. migrate category based alerts
    migrateCategoryAlert();
    //7. fixing the Change Category behavior for incident module
    fixIncidentChangeCategoryAction();
}

function migrateIncidentSecurity() {
    if(IS_UPGRADE_FROM_PD3_UPGHISTORY) {
	    var ret = 0;
	    system.functions.rtecall("trigger", ret, 1);
	    lib.IncidentUpgradeManager.getInstance().upgradeProfiles();
	    system.functions.rtecall("trigger", ret, 0);
        lib.IncidentUpgradeManager.getInstance().upgradeOperators();
        system.functions.rtecall("trigger", ret, 1);
        lib.IncidentUpgradeManager.getInstance().upgradeUserRoles();
        system.functions.rtecall("trigger", ret, 0);
    }
}

function isUpgradeFromPD3() {
    var ret = false;
    var upghis = new SCFile("upgradehistory");
    var rc = upghis.doSelect('true');
    while(rc == RC_SUCCESS) {
        if(upghis["new.version"]==="PD 9.30.3") {// if it is PD4, return false directly
            return false;
        } else if(upghis["new.version"]==="PD 9.30.2") {// if it is PD3, make as true and continue to check whether there is PD4
            ret = true;
        }
        rc = upghis.getNext();
    }
    return ret;
}

function migrateServiceDeskModule() {
    //1. objects
    migrateObjects(SERVICEDESK_OBJECT_NAMES);
    //2. workflow
    createServideDeskWorkflowsByCategories();
    //3. categories, which are migrated together with Incident module, no need here.
    // do nother here
    //4. TODO, migrate security if it is upgraded from PD3, ignore if it is upgraded from non-PD
    migrateServiceDeskSecurity();
    //5. fix 'create new interaction' processing
    fixSDNewProcessing();
    //6. QCCR1E125727, need to enable the setting 'Enable Streamlined Interaction'
    // rollback it by commenting below line, it will be tracked with ER QCCR1E126880.
    //changeSetting("Service Desk", "sd.new.entry.enabled", "true");
}

function migrateServiceDeskSecurity() {
    if(IS_UPGRADE_FROM_PD3_UPGHISTORY) {
	    var ret = 0;
	    system.functions.rtecall("trigger", ret, 1);
	    lib.ServiceDeskUpgradeManager.getInstance().upgradeProfiles();
	    system.functions.rtecall("trigger", ret, 0);
        lib.ServiceDeskUpgradeManager.getInstance().upgradeOperators();
        system.functions.rtecall("trigger", ret, 1);
        lib.ServiceDeskUpgradeManager.getInstance().upgradeUserRoles();
        system.functions.rtecall("trigger", ret, 0);
    }
}

/**
 * @deplicated
 */
function migrateRequestModule() {
    //0. security
    migrateRequestSecurity();
    //1. objects
    migrateObjectsForRequestModule();
    //2. workflows
    createDynamicWorkflowByCategories(REQUEST_OBJECT_NAMES);
    //3. categories
    migrateRequestCategories();
    //4. restore legacy restore menu (keep legacy and PD OOB reqeust run in parallel approach)
    restoreLegacyRequestMenu();
}

function migrateObjectsForNormal() {
    migrateObjects(OBJECT_NAMES);
}

function migrateObjects(objs) {
    printIt("Start migrating Objects...", true);
    var i;
    for(i=0, len=objs.length; i&lt;len; i++) {
        if(migrateObject(objs[i])==false) {
            return false;
        }
    }
    printIt("Finish migrating Objects.", true);
    return true;
}

function migrateObject(obj) {
    if(OPTION==OPT2) {
        return migrateObjectOpt2(obj);
    } else {
        return migrateObjectOpt1(obj);
    }
}

function migrateObjectsForRequestModule() {
    printIt("Start migrating Objects for request module...", true);
    var i;
    for(i=0, len=REQUEST_OBJECT_NAMES.length; i&lt;len; i++) {
        migrateObjectForRequestModule(REQUEST_OBJECT_NAMES[i]);
    }
    printIt("Finish migrating Objects for request module.", true);

    // update datadict to set area field
    printIt("Start updating datadicts to set area field for request module...", true);
    var datadictName;
    for(datadictName in REQUEST_DATADICT_MAPTO_AREA) {
        var datadict = $("datadict").select("name=\"" + datadictName + "\"").uniqueResult();
        if(null == datadict) {
            printIt("Can not found the datadict \"" + datadictName + "\", ignore it!");
            continue;
        }
        var areaName = null;
        if(null!=REQUEST_DATADICT_MAPTO_AREA[datadictName]) {
            areaName=REQUEST_DATADICT_MAPTO_AREA[datadictName];
        } else {
            areaName=getAreaName(datadictName);
        }
        if(null != datadict["sc.area"]) {
            if(datadict["sc.area"]==areaName) {
                printIt("The area of datadict \"" + datadictName + "\" has already been set to \"" + areaName + "\", ignore it!");
            } else if(datadict["sc.area"]!=areaName) {
                printIt("The area of datadict \"" + datadictName + "\" has been set to \"" + datadict["sc.area"] + "\", but the expected value is \"" + areaName + "\", please manually check!");
            }
            continue;
        }

        datadict["sc.area"]=areaName;
        datadict.doUpdate();
        printIt("The area of datadict \"" + datadictName + "\" is updated to \"" + areaName + "\".");
    }
    printIt("Finish updating datadicts to set area field for request module.", true);
}

function migrateObjectOpt1(objectName) {
    printIt(" -&gt; start migrating Object \"" + objectName + "\"...", true);
    //0. check whether this Object is migrated already by checking the existance of the disabled record by PD code migration
    var pdMigrationDisabledObjectFile = $("Object").select("file.name=\"" + objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
    if (null!==pdMigrationDisabledObjectFile) {
        printIt("The Object \"" + objectName + "\" has already been migrated, ignore it!");
        return false;
    }

    //1. rename the PD enabled Object name to xxx_disabled_by_PDCM
    var pdEnabledObjectFile = $("Object").select("file.name=\"" + objectName + "\"").uniqueResult();
    if (null!==pdEnabledObjectFile) {
        pdEnabledObjectFile["file.name"] = objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
        pdEnabledObjectFile.doUpdate();
    } else {
        pdEnabledObjectFile = $("Object").select("file.name=\"" + objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
        printIt("Can not find the original Object \"" + objectName + "\", ignore it!");
    }

    //2. clone from the disabled object (the legacy customer Object) which is disabled by PD enablement, and set PD security/category/workflow info
    var pdMigratedObjectFile = $("Object").select("file.name=\"" + objectName + PD_ENABLEMENT_DISABLE_SUFFIX + "\"").uniqueResult();
    if (null!==pdMigratedObjectFile) {
        // 2.1 rename it
        pdMigratedObjectFile["file.name"] = objectName;
        // 2.2 security
        pdMigratedObjectFile["profile.appl"] = pdEnabledObjectFile["profile.appl"];
        pdMigratedObjectFile["profile.variable"] = pdEnabledObjectFile["profile.variable"];
        // 2.3 category
        pdMigratedObjectFile["category.file.name"] = pdEnabledObjectFile["category.file.name"];
        // 2.4 workflow
        pdMigratedObjectFile["workflowLocation"] = pdEnabledObjectFile["workflowLocation"];
        // 2.5 append $L.mode in to local variables
        var localVarLen = 0;
        if(null!=pdMigratedObjectFile["local.variables"]) {
            localVarLen = pdMigratedObjectFile["local.variables"].length();
        }
        pdMigratedObjectFile["local.variables"][localVarLen] = "$L.mode";
        // 2.6 alert
        pdMigratedObjectFile["alert.recalc"] = pdEnabledObjectFile["alert.recalc"];
        pdMigratedObjectFile["alert.reset"] = pdEnabledObjectFile["alert.reset"];
        // 2.7 approval
        pdMigratedObjectFile["approval.recalc"] = pdEnabledObjectFile["approval.recalc"];
        pdMigratedObjectFile["approval.reset"] = pdEnabledObjectFile["approval.reset"];

        pdMigratedObjectFile.doInsert();
    } else {
        printIt("Can not find the PD disabled Object \"" + objectName + "\", ignore it!");
    }

    //3. For add/update related processes, need to make sure the $L.exit is set to "normal" or "added", otherwise the default/auto transitions will not be executed
    // I am going to enhance the DOC Engine, so that we donot need to change the Processes
    //dealVarExitInProcess(objectName);

    printIt(" -&gt; migrated Object \"" + objectName + "\" done.", true);
    return true;
}

function migrateObjectOpt2(objectName) {
    printIt(" -&gt; start migrating Object \"" + objectName + "\"...", true);


    //0. check whether this Object is migrated already by checking the existance of the disabled record by PD code migration
    var pdMigrationDisabledObjectFile = $("Object").select("file.name=\"" + objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
    if (null!==pdMigrationDisabledObjectFile) {
        printIt("The Object \"" + objectName + "\" has already been migrated, ignore it!");
        return false;
    }

    // if it is not from PD3, then the pd enablement script should be run before running this code migration tool, so the tool
    var isUpgradeFromPD3Flag = isUpgradeFromPD3(); // here I do not use the const otherwise the UT case will fail.
    var hasCustomization = true;
    if(isUpgradeFromPD3Flag) {
        var upgradeObjectFile = $("Object", SCFILE_READONLY).select("file.name=\"" + UPGRADE_PREFIX + objectName + "\"").uniqueResult();
        if(null==upgradeObjectFile) {
            hasCustomization = false;
        }
    }

    
    

    //1. rename the Object name to xxx_disabled_by_PDCM, which is
    //   . either the PD enabled object if the system is upgrade from non-PD, or the system is upgrade from PDCP3 but there is not any customization on this object
    //   . or, the non-PD object if the system is upgrade from PDCP3 but there is some customization on this object
    var reportObj = {};
    var changedFiles = [];
    reportObj.files = changedFiles;
    reportObj.category="Object";
    reportObj.filename ="object";
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    if(isUpgradeFromPD3Flag==true) {
        if(hasCustomization==false) {
            reportObj.title="The following object is replaced with the out-of-box Process Designer-based version. Backups of the original object (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
            changedFiles.push(objectName);
            printIt("The object \"" + objectName + "is replaced with the out-of-box Process Designer-based version. Backups of the original object (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.");
             
        }else {
            reportObj.title="The following object is replaced with the out-of-box Process Designer-based version plus your customozation on original object. Backups of the original object (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
            changedFiles.push(objectName);
            printIt("The object \"" + objectName + "is replaced with the out-of-box Process Designer-based version plus your customozation on original object. Backups of the original object (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.");        
           
        }
    } else {
        changedFiles.push("The original record \"" + objectName + "\" is backuped and renamed to \"" + objectName + PD_ENABLEMENT_DISABLE_SUFFIX + "\"");
        changedFiles.push("The PD OOB record is renamed to \"" + objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"");
    }
    var orgObjectFile = $("Object").select('file.name="' + objectName + '"').uniqueResult();
    if (null!==orgObjectFile) {
        orgObjectFile["file.name"] = objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
        if(isUpgradeFromPD3Flag==true &amp;&amp; hasCustomization==false) {
            // if no customization on the Object, just copy the orginal Object with PD code migration disable suffix, which marks this module is enabled.
            orgObjectFile.doInsert();
            
            // remove the empty items from array fields in case there are any empty items
            orgObjectFile = $("Object").select('file.name="' + objectName + '"').uniqueResult();
            // make sure the fields $L.lastinc, $L.oldinc and $L.mode.add be in local.variables for incidents object
	        var addDefaultForSD = false;
	        if(objectName==="incidents") {
	            if(!arrayContains(orgObjectFile["local.variables"], "$L.lastinc")) {
	                orgObjectFile["local.variables"].push("$L.lastinc");
	                addDefaultForSD = true;
	            }
	            if(!arrayContains(orgObjectFile["local.variables"], "$L.oldinc")) {
	                orgObjectFile["local.variables"].push("$L.oldinc");
                    addDefaultForSD = true;
                }
                if (!arrayContains(orgObjectFile["local.variables"], "$L.cost")) {
                    orgObjectFile["local.variables"].push("$L.cost");
                    addDefaultForSD = true;
                }
                if (!arrayContains(orgObjectFile["local.variables"], "$L.display.cost")) {
                    orgObjectFile["local.variables"].push("$L.display.cost");
                    addDefaultForSD = true;
                }
                if (!arrayContains(orgObjectFile["local.variables"], "$L.value.cost")) {
                    orgObjectFile["local.variables"].push("$L.value.cost");
                    addDefaultForSD = true;
                }
                if (!arrayContains(orgObjectFile["local.variables"], "$L.handle.start")) {
                    orgObjectFile["local.variables"].push("$L.handle.start");
                    addDefaultForSD = true;
                }
                if (!arrayContains(orgObjectFile["local.variables"], "$L.pmtapi")) {
                    orgObjectFile["local.variables"].push("$L.pmtapi");
                    addDefaultForSD = true;
                }
	            if(!arrayContains(orgObjectFile["local.variables"], "$L.mode.add")) {
	                orgObjectFile["local.variables"].push("$L.mode.add");
	                addDefaultForSD = true;
	            }
                //for Exit &amp; New
                if (!arrayContains(orgObjectFile["local.variables"], "$L.viewLastInteraction")) {
                    orgObjectFile["local.variables"].push("$L.viewLastInteraction");
                    addDefaultForSD = true;
                }
            }
            var removeEmptyItemsFlag1 = removeEmptyItemsFromArray(orgObjectFile, "assignedToFields", null);
            var removeEmptyItemsFlag2 = removeEmptyItemsFromArray(orgObjectFile, "workgroupFields", null);
            var removeEmptyItemsFlag3 = removeEmptyItemsFromArray(orgObjectFile, "local.variables", null);
            var removeEmptyItemsFlag4 = removeEmptyItemsFromArray(orgObjectFile, "global.lists", null);
            var removeEmptyItemsFlag5 = removeEmptyItemsFromArray(orgObjectFile, "parent.id", ["parent.object"]);
            var removeEmptyItemsFlag6 = removeEmptyItemsFromArray(orgObjectFile, "watch.variables", ["watch.variable.name", "watch.variable.type", "watch.variable.global.list"]);
            if (addDefaultForSD || removeEmptyItemsFlag1
              || removeEmptyItemsFlag2
              || removeEmptyItemsFlag3
              || removeEmptyItemsFlag4
              || removeEmptyItemsFlag5
              || removeEmptyItemsFlag6) {
                orgObjectFile.doUpdate();
            }

            return true;
        } else {
            orgObjectFile.doUpdate();
        }
    } else {
        printIt("Can not find the original Object \"" + objectName + "\", ignore it!");
    }

    // get PD OOB Object
    var pdEnabledObjectFile = null;
    var legacyObjectFile = null;
    if(isUpgradeFromPD3Flag==true) {
        if(hasCustomization==true) {
           pdEnabledObjectFile = $("Object").select('file.name="' + UPGRADE_PREFIX + objectName + '"').uniqueResult();
           legacyObjectFile = $("Object", SCFILE_READONLY).select("file.name=\"" + objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
        } else {
            // already return above, no need to handle here
        }
    } else { // from non-PD
        pdEnabledObjectFile = $("Object").select('file.name="' + objectName + PD_CODE_MIGRATION_DISABLE_SUFFIX + '"').uniqueResult();
        legacyObjectFile = $("Object", SCFILE_READONLY).select("file.name=\"" + objectName + PD_ENABLEMENT_DISABLE_SUFFIX + "\"").uniqueResult();
        //currently, PD OOB goes here, so add this line, may refine later.
        if(!legacyObjectFile) {
        	legacyObjectFile=pdEnabledObjectFile;
        }
    }
    
    

    //2. clone from the the PD OOB Object, and set PD security/category/workflow info
    var pdMigratedObjectFile = pdEnabledObjectFile;
    if (null!==pdMigratedObjectFile) {
        // 2.1 rename it
        pdMigratedObjectFile["file.name"] = objectName;

        // 2.2 keep to use legacy customized data for following fields
        pdMigratedObjectFile["number.record"] = legacyObjectFile["number.record"];
        pdMigratedObjectFile["phase.file.name"] = legacyObjectFile["phase.file.name"];
        pdMigratedObjectFile["paging.file"] = legacyObjectFile["paging.file"];
        pdMigratedObjectFile["joindef"] = legacyObjectFile["joindef"];
        pdMigratedObjectFile["statusField"] = legacyObjectFile["statusField"];
        pdMigratedObjectFile["use.locking"] = legacyObjectFile["use.locking"];
        pdMigratedObjectFile["lock.on.display"] = legacyObjectFile["lock.on.display"];
        pdMigratedObjectFile["lock.parent"] = legacyObjectFile["lock.parent"];
        //pdMigratedObjectFile["category.file.name"] for category file name, always use PD OOB

        // 2.3 merge legacy Assigned to fields to this Object
        mergeArrayFieldValue(pdMigratedObjectFile, legacyObjectFile, "assignedToFields");
        // 2.4 merge legacy Workgroup fields to this Object
        mergeArrayFieldValue(pdMigratedObjectFile, legacyObjectFile, "workgroupFields");
        // 2.5 merge legacy local variables to this Object
        mergeArrayFieldValue(pdMigratedObjectFile, legacyObjectFile, "local.variables");
        // make sure the fields $L.lastinc, $L.oldinc and $L.mode.add be in local.variables for incidents object
        if(objectName==="incidents") {
            if(!arrayContains(pdMigratedObjectFile["local.variables"], "$L.lastinc")) {
                pdMigratedObjectFile["local.variables"].push("$L.lastinc");
            }
            if(!arrayContains(pdMigratedObjectFile["local.variables"], "$L.oldinc")) {
                pdMigratedObjectFile["local.variables"].push("$L.oldinc");
            }

            if (!arrayContains(pdMigratedObjectFile["local.variables"], "$L.cost")) {
                pdMigratedObjectFile["local.variables"].push("$L.cost");
            }
            if (!arrayContains(pdMigratedObjectFile["local.variables"], "$L.display.cost")) {
                pdMigratedObjectFile["local.variables"].push("$L.display.cost");
            }
            if (!arrayContains(pdMigratedObjectFile["local.variables"], "$L.value.cost")) {
                pdMigratedObjectFile["local.variables"].push("$L.value.cost");
            }
            if (!arrayContains(pdMigratedObjectFile["local.variables"], "$L.handle.start")) {
                pdMigratedObjectFile["local.variables"].push("$L.handle.start");
            }
            if (!arrayContains(pdMigratedObjectFile["local.variables"], "$L.pmtapi")) {
                pdMigratedObjectFile["local.variables"].push("$L.pmtapi");
            }
            if(!arrayContains(pdMigratedObjectFile["local.variables"], "$L.mode.add")) {
                pdMigratedObjectFile["local.variables"].push("$L.mode.add");
            }
            //for Exit &amp; New
            if (!arrayContains(pdMigratedObjectFile["local.variables"], "$L.viewLastInteraction")) {
                pdMigratedObjectFile["local.variables"].push("$L.viewLastInteraction");
            }
        }
        // 2.6 merge legacy global list to this Object
        mergeArrayFieldValue(pdMigratedObjectFile, legacyObjectFile, "global.lists");
        // 2.7 merge legacy Parent Lock Information and Watch Variables
        mergeArrayFieldValue(pdMigratedObjectFile, legacyObjectFile, "parent.id", ["parent.object"]);
        mergeArrayFieldValue(pdMigratedObjectFile, legacyObjectFile, "watch.variables", ["watch.variable.name", "watch.variable.type", "watch.variable.global.list"]);

        // 2.7 alert, no need as we are using PD based OOB?
        // 2.8 approval, no need as we are using PD based OOB

        pdMigratedObjectFile.doInsert();
        addMigrationPatchRecord("Object", pdMigratedObjectFile, pdMigratedObjectFile["file.name"], false);
    } else {
        printIt("Can not find the PD OOB Object for \"" + objectName + "\", ignore it!");
        return false;
    }

    //3. For add/update related processes, need to make sure the $L.exit is set to "normal" or "added", otherwise the default/auto transitions will not be executed
    // I am going to enhance the DOC Engine, so that we donot need to change the Processes
    //dealVarExitInProcess(objectName);

    printIt(" -&gt; migrated Object \"" + objectName + "\" done.", true);
    return true;
}

function migrateObjectForRequestModule(objectName) {
    printIt(" -&gt; start migrating Object \"" + objectName + "\"...", true);
    //0. check whether this Object is migrated already by checking the object existance and its workflowLocation is not null.
    var objectFile = $("Object").select("file.name=\"" + objectName + "\"").uniqueResult();
    if (null!=objectFile &amp;&amp; null!=objectFile.workflowLocation) {
        printIt("The Object \"" + objectName + "\" has already been migrated, ignore it!");
        return;
    }

    //1. copy the Object from the legacy disabled one (xxx_disabled_by_PDRM) if the object does not exist
    if(null==objectFile) {
	    var legacyObjectFile = $("Object").select("file.name=\"" + objectName + PD_ENABLEMENT_DISABLE_SUFFIX_REQ + "\"").uniqueResult();
	    if (null!==legacyObjectFile) {
	        legacyObjectFile["file.name"] = objectName;
	        legacyObjectFile["workflowLocation"] = "category";
	        legacyObjectFile["profile.appl"] = "secRoleBasedAccess";
	        legacyObjectFile["profile.variable"] = "$L.env";
	        if(null==legacyObjectFile["unique.field"] || legacyObjectFile["unique.field"].length()==0 || legacyObjectFile["unique.field"][0]==null) {
	            legacyObjectFile["unique.field"] = ["phase.num"]; // the unique key field was cleared in Object ocml in oob after enabling PD request module
	        }
	        legacyObjectFile.doInsert();
	    } else {
	        printIt("Can not find the original Object \"" + objectName + "\", ignore it!");
	        return;
	    }
    }

    printIt(" -&gt; migrated Object \"" + objectName + "\" done.", true);
}

/**
 * @deplicated
 */
function dealVarExitInProcess(objectName) {
	var obj = $("Object").select("file.name=\"" + objectName + "\"").uniqueResult();
	if(null==obj) {
		return;
	}
	var states = [];
	if(OPTION==OPT2) {
	    if(obj["alt.open.state"]!=null &amp;&amp; obj["alt.open.state"]!="") {
		    states.push(obj["alt.open.state"]);
		}
		if(obj["alt.close.state"]!=null &amp;&amp; obj["alt.close.state"]!="") {
		    states.push(obj["alt.close.state"]);
		}
		if(obj["alt.default.state"]!=null &amp;&amp; obj["alt.default.state"]!="") {
		    states.push(obj["alt.default.state"]);
		}
	} else {
		if(obj["open.state"]!=null &amp;&amp; obj["open.state"]!="") {
		    states.push(obj["open.state"]);
		}
		if(obj["close.state"]!=null &amp;&amp; obj["close.state"]!="") {
		    states.push(obj["close.state"]);
		}
		if(obj["default.state"]!=null &amp;&amp; obj["default.state"]!="") {
		    states.push(obj["default.state"]);
		}
	}

    //1. retrieve add/new/save Processes from state
    var processNames = {};
    var i,j;
	for(i=0, len=states.length; i&lt;len; i++) {
	    var state = new SCFile("States", SCFILE_READONLY);
	    var rc = state.doSelect('state="' + states[i] + '"');
	    if(rc==RC_SUCCESS &amp;&amp; state["process.label"]!=null) {
	        for(j=0, lenJ=state["process.label"].length(); j&lt;lenJ; j++) {
	            var processLabel = state["process.label"][j];
	            if(_str.startsWith(processLabel,"save") || _str.startsWith(processLabel,"add") || _str.startsWith(processLabel,"new")) {
	                processNames[state["valid.process"][j]] = true;
	            }
	        }
	    }
	}

	//2. append -- if ($L.exit~="bad.val") then ($L.exit="normal") -- to the end of the post.expressions of the Process
	var addedExpressionLine = 'if ($L.exit~="bad.val" and $L.exit~="badval") then ($L.exit="normal")';
	var p;
	for(p in processNames) {
	    printIt("Starting to append $L.exit logic at the end of the post.expressions of the Process \"" + p + "\"");
	    var process = new SCFile("Process");
	    var rc = process.doSelect('process="' + p + '"');
	    if(rc==RC_SUCCESS) {
	        process["post.expressions"] = system.functions.denull(process["post.expressions"]);
	        var expLen = process["post.expressions"].length();
	        if(process["post.expressions"]==null
	          || process["post.expressions"].length()&lt;=0
	          || system.functions.str(process["post.expressions"][expLen-1]) != addedExpressionLine) {
                process["post.expressions"].push(system.functions.parse(addedExpressionLine,11));
                printIt("The Process \"" + p + "\" is appended the $L.exit logic");
                process.doAction("save");
            } else {
                printIt("The Process \"" + p + "\" is already matched, ignore it");
            }
        } else {
            printIt("Can not find the Process according to name \"" + p + "\", ignore it");
        }
	}
}

function cleanOOBWorkflows() {
    printIt("Start cleaning OOB Workflows...", true);
    var i;
    for(i=0, len=OBJECT_NAMES.length; i&lt;len; i++) {
        cleanWorkflowsByTableName(OBJECT_NAMES[i]);
    }
    printIt("Finish cleaning OOB Workflows.", true);
}

function cleanWorkflowsByTableName(tableName) {
    printIt(" -&gt; start cleaning workflows of table \"" + tableName + "\"...");
    var workflow = new SCFile("Workflow");
    var rc = workflow.doSelect('tableName="' + tableName + '"');
    while(rc == RC_SUCCESS) {
        if(_.endsWith(workflow["name"], PD_CODE_MIGRATION_DISABLE_SUFFIX)) {
            // ignore it, as it is already the disabled one
            printIt("Ingore the workflow \"" + workflow["name"] + "\" as it is alread disabled!");
        } else {
            var orgName = workflow["name"];
            // rename the workflow name in workflow phases
            var phases = new SCFile("WorkflowPhase");
            var rc2 = phases.doSelect('tableName="' + tableName + '" and workflowName="' + orgName + '"');
            while(rc2 == RC_SUCCESS) {
                phases["workflowName"] = orgName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
                phases.doUpdate();
                rc2 = phases.getNext();
            }
            // rename the workflow name itself to disabled one
            workflow["name"] = orgName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
            workflow.doUpdate();
            printIt("Renamed the workflow name from \"" + orgName + "\" to \"" + workflow["name"] + "\".");
        }
        rc = workflow.getNext();
    }
    printIt(" -&gt; cleaning workflows of table \"" + tableName + "\" done.");
}

/*
function createWorkflowsByCategories() {
    //1. create incident workflow
    createIncidentWorkflowsByCategories()

    //2. create service desk workflow
    createServideDeskWorkflowsByCategories()

    //3. create request workflows
    createDynamicWorkflowByCategories(REQUEST_OBJECT_NAMES);
}
*/

function createIncidentWorkflowsByCategories() {
    var pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "Incident";
    var tableName = "probsummary";
    createFixedWorkflowByCategories(true, pdMigratedWorkflowName, tableName);
}

function createServideDeskWorkflowsByCategories() {
    pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "ServiceDesk";
    tableName = "incidents";
    createFixedWorkflowByCategories(false, pdMigratedWorkflowName, tableName);
    appendSDBGtransition(pdMigratedWorkflowName);
}

function html2Escape(sHtml) {
 return sHtml.replace(/[&lt;&gt;&amp;"]/g,function(c){return {'&lt;':'&amp;lt;','&gt;':'&amp;gt;','&amp;':'&amp;amp;','"':'&amp;quot;'}[c];});
}

function createFixedWorkflowByCategories(hasLogging, pdMigratedWorkflowName, tableName, legacyObjectName, legacyWF) {
    // set trigger on to make sure the related scmsg could be auto generated
    var ret = 0;
	system.functions.rtecall("trigger", ret, 1);

    printIt("Creating Workflow \"" + pdMigratedWorkflowName + "\" for table \"" + tableName + "...", true);
    // 0. check if this workflow is already added
    var pdMigratedWorkflow = $("Workflow").select("tableName=\"" + tableName + "\" and name=\"" + pdMigratedWorkflowName + "\"").uniqueResult();
    if (null!==pdMigratedWorkflow) {
        printIt("The Workflow \"" + pdMigratedWorkflowName + "\" has already been migrated, ignore it!");
        return;
    }

    var objectFile = $("Object").select("file.name=\"" + tableName + "\"").uniqueResult();
    var legacyObjectFile = null;
    if(legacyObjectName!=null) {
        legacyObjectFile = $("Object", SCFILE_READONLY).select("file.name=\"" + legacyObjectName + "\"").uniqueResult();
    } else {
        // assume it is upgrade from non-PD, and the pd enablement script has been run
        legacyObjectFile = $("Object", SCFILE_READONLY).select("file.name=\"" + tableName + PD_ENABLEMENT_DISABLE_SUFFIX + "\"").uniqueResult();
        if(null == legacyObjectFile) {
            // assume it is upgraded from PDCP3, and has customization on Object
            legacyObjectFile = $("Object", SCFILE_READONLY).select("file.name=\"" + tableName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\" and workflowLocation=NULL").uniqueResult();
            if(null == legacyObjectFile) {
                // keep it as null, assume it is upgraded from PDCP3 and no customization on Object.
            }
        }
    }

    if(null==objectFile) {
        printIt("Can not find the Object \"" + tableName + "\", ignore creating workflow!", true);
        return;
    }
    var altOpenStateDSName = null;
    if(legacyObjectFile!=null) {
        altOpenStateDSName = legacyObjectFile["open.state"];
    } else {
        if(tableName==="probsummary") {
            altOpenStateDSName = "im.open";
        } else if(tableName==="incidents") {
            altOpenStateDSName = "sm.open";
        } else if(tableName==="cm3r") {
            altOpenStateDSName = "cm.open";
        } else if(tableName==="cm3t") {
            altOpenStateDSName = "change.open";
        }
    }
    var altOpenStateDS = $("States").select("state=\"" + altOpenStateDSName + "\"").uniqueResult();
    if(null == altOpenStateDS) {
        printIt("Can not find the alternative open state\"" + altOpenStateDSName + "\", use default db.view!");
        altOpenStateDS = $("States").select("state=\"db.view\"").uniqueResult();
    }
    var altDefaultStateDSName = null;
    if(legacyObjectFile!=null) {
        altDefaultStateDSName = legacyObjectFile["default.state"];
    } else {
        if(tableName==="probsummary") {
            altDefaultStateDSName = "im.view";
        } else if(tableName==="incidents") {
            altDefaultStateDSName = "sm.view";
        } else if(tableName==="cm3r") {
            altDefaultStateDSName = "cm.view";
        } else if(tableName==="cm3t") {
            altDefaultStateDSName = "change.view";
        }
    }
    var altDefaultStateDS = $("States").select("state=\"" + altDefaultStateDSName + "\"").uniqueResult();
    if(null == altDefaultStateDS) {
        printIt("Can not find the alternative default state\"" + altDefaultStateDSName + "\", use default db.view!");
        altDefaultStateDS = $("States").select("state=\"db.view\"").uniqueResult();
    }
    var openStateDS = $("displayscreen").select("screen.id=\"" + altOpenStateDS["display.screen"] + "\"").uniqueResult();
    if(null == openStateDS) {
        printIt("Can not find the display screen\"" + altOpenStateDS["display.screen"] + "\", ignore creating workflow!");
        return;
    }
    var defaultStateDS = $("displayscreen").select("screen.id=\"" + altDefaultStateDS["display.screen"] + "\"").uniqueResult();
    if(null == openStateDS) {
        printIt("Can not find the display screen\"" + altDefaultStateDS["display.screen"] + "\", ignore creating workflow!");
        return;
    }

    // 1. add the workflow
    // 1.1 workflow record itself
    var body = {
        "name": pdMigratedWorkflowName,
        "tableName": tableName,
        "defaultPhase": PHASE_NAME_INPROGRESS,
        "firstPhase": hasLogging ? PHASE_NAME_LOGGING : PHASE_NAME_INPROGRESS
    };
    body["optimize.autotran.save"] = true;
    body["onDisplayRules"] = ["common.relatedrecord.init.vars", "common.workflow.init.vars"];
    if(legacyWF!==false) {
        body["is.legacy.workflow"] = true;
	    if(legacyObjectFile!=null) {
		    body["legacy.fc"] = legacyObjectFile["master.fc"];
		    body["legacy.open.state"] = legacyObjectFile["open.state"];
		    body["legacy.close.state"] = legacyObjectFile["close.state"];
		    body["legacy.default.state"] = legacyObjectFile["default.state"];
            body["legacy.browse.state"] = legacyObjectFile["browse.state"];
	    } else {
		    body["legacy.fc"] = tableName;
	        if(tableName==="probsummary") {
			    body["legacy.open.state"] = "im.open";
			    body["legacy.close.state"] = null;
			    body["legacy.default.state"] = "im.view";
                body["legacy.browse.state"] = "im.browse";
	        } else if(tableName==="incidents") {
	            body["legacy.open.state"] = "sm.open";
			    body["legacy.close.state"] = null;
			    body["legacy.default.state"] = "sm.view";
                body["legacy.browse.state"] = "sm.browse";
	        } else if(tableName==="cm3r") {
	            body["legacy.open.state"] = "cm.open";
			    body["legacy.close.state"] = null;
			    body["legacy.default.state"] = "cm.view";
                body["legacy.browse.state"] = "cm.browse";
	        } else if(tableName==="cm3t") {
	            body["legacy.open.state"] = "change.open";
			    body["legacy.close.state"] = null;
			    body["legacy.default.state"] = "change.view";
                body["legacy.browse.state"] = "cm.browse";
	        }
	    }
	}
    var workflow = addWorkflow(body);

    // 1.2. create phase "Logging"
    var phase1 = {
        "phaseName": PHASE_NAME_LOGGING,
        "workflowName": pdMigratedWorkflowName,
        "tableName": tableName,
        "xCoordinate": FIRST_PHASE_X,
        "yCoordinate": FIRST_PHASE_Y,
        "active": true,
        "phaseOrder":1
       };
    if(openStateDS.io != null) {
        var ioStr = system.functions.str(openStateDS.io);
        phase1["updateCond"] = ioStr;
        phase1["updateCondXML"] = '&lt;XmlCondition&gt;&lt;collection logical="" negate=""&gt;'
           + '&lt;condition logical="" negate="false"&gt;&lt;operand type="expression"&gt;'
           + '&lt;Expression caption=""&gt;"' + html2Escape(ioStr) + '"&lt;/Expression&gt;'
           + '&lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;';
        phase1["updateCondDesc"] = "( Expression: " + ioStr + ")";
    }
    var loggingPhase = hasLogging ? addWorkflowPhase(phase1) : null;

    // 1.3. create phase "In Progress"
    var phase2 = {
        "phaseName": PHASE_NAME_INPROGRESS,
        "workflowName": pdMigratedWorkflowName,
        "tableName": tableName,
        "xCoordinate": FIRST_PHASE_X+PHASE_SPACING*1,
        "yCoordinate": FIRST_PHASE_Y,
        "active": true,
        "phaseOrder":2 };
    if(defaultStateDS.io != null) {
        var ioStr = system.functions.str(defaultStateDS.io);
        if (!hasLogging) {
            ioStr = "(($L.mode~=\"add\") and (" + ioStr + ")) " + " or " + "(($L.mode=\"add\") and (" + phase1["updateCond"] + ")) ";
        }
        phase2["updateCond"] = ioStr;
        phase2["updateCondXML"] = '&lt;XmlCondition&gt;&lt;collection logical="" negate=""&gt;'
           + '&lt;condition logical="" negate="false"&gt;&lt;operand type="expression"&gt;'
           + '&lt;Expression caption=""&gt;"' + html2Escape(ioStr) + '"&lt;/Expression&gt;'
           + '&lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;';
        phase2["updateCondDesc"] = "( Expression: " + ioStr + ")";
    }
    var inProgressPhase = addWorkflowPhase(phase2);

    // 1.4 add default transitiion between phase 1 and phase 2
    var transitionBody = {
        "toPhase": PHASE_NAME_INPROGRESS
    };
    loggingPhase = hasLogging ? addDefaultTransition(PHASE_NAME_LOGGING, pdMigratedWorkflowName, tableName, transitionBody) : null;

    // 1.5. create phase "Closure"
    var phase3 = {
        "phaseName": PHASE_NAME_CLOSURE,
        "workflowName": pdMigratedWorkflowName,
        "tableName": tableName,
        "xCoordinate": FIRST_PHASE_X+PHASE_SPACING*2,
        "yCoordinate": FIRST_PHASE_Y,
        "active": true,
        "phaseOrder":3 };
    if(defaultStateDS.io != null) {
        var ioStr = system.functions.str(defaultStateDS.io);
        phase3["updateCond"] = ioStr;
        phase3["updateCondXML"] = '&lt;XmlCondition&gt;&lt;collection logical="" negate=""&gt;'
           + '&lt;condition logical="" negate="false"&gt;&lt;operand type="expression"&gt;'
           + '&lt;Expression caption=""&gt;"' + html2Escape(ioStr) + '"&lt;/Expression&gt;'
           + '&lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;';
        phase3["updateCondDesc"] = "( Expression: " + ioStr + ")";
    }
    var closurePhase = addWorkflowPhase(phase3);

    var statuesField = objectFile.statusField;
    // 1.6 add auto transitiion from phase 2 (In Progress) to phase 3 (Closure)
    transitionBody = {
        "atToPhase": PHASE_NAME_CLOSURE,
        "atCondition": statuesField + ' in $L.file="Closed" or ' + statuesField + ' in $L.file="Resolved"',
        "atCondXML": '&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;&lt;operand type=\"field\"&gt;&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;&lt;FieldName caption=\"Status\"&gt;' + statuesField + '&lt;/FieldName&gt;&lt;/operand&gt;&lt;Comparison&gt;equals&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;Closed&lt;/Value&gt;&lt;/condition&gt;&lt;condition logical=\"OR\" negate=\"false\"&gt;&lt;operand type=\"field\"&gt;&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;&lt;FieldName caption=\"Status\"&gt;' + statuesField + '&lt;/FieldName&gt;&lt;/operand&gt;&lt;Comparison&gt;equals&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;Resolved&lt;/Value&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;',
        "atCondDesc": '( Status in CurrentRecord = \"Closed\" OR Status in CurrentRecord = \"Resolved\")',
        "atxCoordinate":0,
        "atyCoordinate":0,
        "atDescription": ""
    };
    inProgressPhase = addAutoTransition(PHASE_NAME_INPROGRESS, pdMigratedWorkflowName, tableName, transitionBody);

    // 1.7 add auto transitiion from phase 3 (Closure) to phase 2 (In Progress) 
    transitionBody = {
        "atToPhase": PHASE_NAME_INPROGRESS,
        "atCondition": 'not  (same(' + statuesField + ' in $L.file, "Closed")) and not  (same(' + statuesField + ' in $L.file, "Resolved"))',
        "atCondXML": '&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;&lt;operand type=\"field\"&gt;&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;&lt;FieldName caption=\"Status\"&gt;' + statuesField + '&lt;/FieldName&gt;&lt;/operand&gt;&lt;Comparison&gt;neq&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;Closed&lt;/Value&gt;&lt;/condition&gt;&lt;condition logical=\"AND\" negate=\"false\"&gt;&lt;operand type=\"field\"&gt;&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;&lt;FieldName caption=\"Status\"&gt;' + statuesField + '&lt;/FieldName&gt;&lt;/operand&gt;&lt;Comparison&gt;neq&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;Resolved&lt;/Value&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;',
        "atCondDesc": '( Status in CurrentRecord != \"Closed\" AND Status in CurrentRecord != \"Resolved\")',
        "atxCoordinate":FIRST_PHASE_X+PHASE_SPACING*1+120,
        "atyCoordinate":FIRST_PHASE_Y+100,
        "atDescription": ""
    };
    closurePhase = addAutoTransition(PHASE_NAME_CLOSURE, pdMigratedWorkflowName, tableName, transitionBody);

    // 1.8 add dynamic forms according to the configuration in category for Incident workflow
    if(tableName === "probsummary") {
        var category = new SCFile("category");
        var rc = category.doSelect('active=true');
        var idx = 0;
        var idx2 = 0;
        while(rc == RC_SUCCESS) {
            // logging phase
            loggingPhase.altForm[idx].altFormId = idx;
            loggingPhase.altForm[idx]["altFormName"] = category["open.format"];
            loggingPhase.altForm[idx]["altFormDesc"] = category["open.format"];
            loggingPhase.altForm[idx]["altFormCondition"] = 'category in $L.file="' + category["name"] + '"';
            loggingPhase.altForm[idx]["altFormCondXML"] = '&lt;XmlCondition&gt;'
                + '&lt;collection logical="" negate=""&gt;'
                + '&lt;condition logical="" negate="false"&gt;'
                + '&lt;operand type="field"&gt;'
                + '&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;'
                + '&lt;FieldName caption="Category"&gt;category&lt;/FieldName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType="string"&gt;' + category["name"] + '&lt;/Value&gt;'
                + '&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;';
            loggingPhase.altForm[idx]["altFormCondDesc"] = '( Category in CurrentRecord = "' + category["name"] + '")';
            loggingPhase.altForm[idx]["altFormType"] = "disp";
    
            // in_progress phase for update mode
            inProgressPhase.altForm[idx2]["altFormId"] = idx2;
            inProgressPhase.altForm[idx2]["altFormName"] = category["update.format"];
            inProgressPhase.altForm[idx2]["altFormDesc"] = category["update.format"];
            inProgressPhase.altForm[idx2]["altFormCondition"] = 'category in $L.file="' + category["name"] + '" and not (same($L.mode, "close"))';
            inProgressPhase.altForm[idx2]["altFormCondXML"] = '&lt;XmlCondition&gt;'
                + '&lt;collection logical="" negate=""&gt;'
                + '&lt;condition logical="" negate="false"&gt;'
                + '&lt;operand type="field"&gt;'
                + '&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;'
                + '&lt;FieldName caption="Category"&gt;category&lt;/FieldName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType="string"&gt;' + category["name"] + '&lt;/Value&gt;'
                + '&lt;/condition&gt;'
                + '&lt;condition logical=\"AND\" negate=\"false\"&gt;'
                + '&lt;operand type=\"variable\"&gt;'
                + '&lt;VariableName caption=\"$L.mode\"&gt;$L.mode&lt;/VariableName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;neq&lt;/Comparison&gt;'
                + '&lt;Value dataType=\"string\"&gt;close&lt;/Value&gt;&lt;/condition&gt;'
                + '&lt;/collection&gt;'
                + '&lt;/XmlCondition&gt;';
            inProgressPhase.altForm[idx2]["altFormCondDesc"] = '( Category in CurrentRecord = "' + category["name"] + '" AND $L.mode != \"close\")';
            inProgressPhase.altForm[idx2]["altFormType"] = "disp";

            // closure phase for close mode
            closurePhase.altForm[idx2]["altFormId"] = idx2;
            closurePhase.altForm[idx2]["altFormName"] = category["close.format"];
            closurePhase.altForm[idx2]["altFormDesc"] = category["close.format"];
            closurePhase.altForm[idx2]["altFormCondition"] = 'category in $L.file="' + category["name"] + '" and not (same($L.action, "reopen"))';
            closurePhase.altForm[idx2]["altFormCondXML"] = '&lt;XmlCondition&gt;'
                + '&lt;collection logical="" negate=""&gt;'
                + '&lt;condition logical="" negate="false"&gt;'
                + '&lt;operand type="field"&gt;'
                + '&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;'
                + '&lt;FieldName caption="Category"&gt;category&lt;/FieldName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType="string"&gt;' + category["name"] + '&lt;/Value&gt;'
                + '&lt;/condition&gt;'
                + '&lt;condition logical=\"AND\" negate=\"false\"&gt;'
                + '&lt;operand type=\"variable\"&gt;'
                + '&lt;VariableName caption=\"$L.mode\"&gt;$L.action&lt;/VariableName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;neq&lt;/Comparison&gt;'
                + '&lt;Value dataType=\"string\"&gt;reopen&lt;/Value&gt;&lt;/condition&gt;'
                + '&lt;/collection&gt;'
                + '&lt;/XmlCondition&gt;';
            closurePhase.altForm[idx2]["altFormCondDesc"] = '( Category in CurrentRecord = "' + category["name"] + '" AND $L.action != \"reopen\")';
            closurePhase.altForm[idx2]["altFormType"] = "disp";

            // in_progress phase for close mode
            idx2++;
            inProgressPhase.altForm[idx2]["altFormId"] = idx2;
            inProgressPhase.altForm[idx2]["altFormName"] = category["close.format"];
            inProgressPhase.altForm[idx2]["altFormDesc"] = category["close.format"];
            inProgressPhase.altForm[idx2]["altFormCondition"] = 'category in $L.file="' + category["name"] + '" and same($L.mode, "close")';
            inProgressPhase.altForm[idx2]["altFormCondXML"] = '&lt;XmlCondition&gt;'
                + '&lt;collection logical="" negate=""&gt;'
                + '&lt;condition logical="" negate="false"&gt;'
                + '&lt;operand type="field"&gt;'
                + '&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;'
                + '&lt;FieldName caption="Category"&gt;category&lt;/FieldName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType="string"&gt;' + category["name"] + '&lt;/Value&gt;'
                + '&lt;/condition&gt;'
                + '&lt;condition logical=\"AND\" negate=\"false\"&gt;'
                + '&lt;operand type=\"variable\"&gt;'
                + '&lt;VariableName caption=\"$L.mode\"&gt;$L.mode&lt;/VariableName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType=\"string\"&gt;close&lt;/Value&gt;&lt;/condition&gt;'
                + '&lt;/collection&gt;'
                + '&lt;/XmlCondition&gt;';
            inProgressPhase.altForm[idx2]["altFormCondDesc"] = '( Category in CurrentRecord = "' + category["name"] + '" AND $L.mode = \"close\")';
            inProgressPhase.altForm[idx2]["altFormType"] = "disp";

            // closure phase for reopen mode
            closurePhase.altForm[idx2]["altFormId"] = idx2;
            closurePhase.altForm[idx2]["altFormName"] = category["update.format"];
            closurePhase.altForm[idx2]["altFormDesc"] = category["update.format"];
            closurePhase.altForm[idx2]["altFormCondition"] = 'category in $L.file="' + category["name"] + '" and (same($L.action, "reopen"))';
            closurePhase.altForm[idx2]["altFormCondXML"] = '&lt;XmlCondition&gt;'
                + '&lt;collection logical="" negate=""&gt;'
                + '&lt;condition logical="" negate="false"&gt;'
                + '&lt;operand type="field"&gt;'
                + '&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;'
                + '&lt;FieldName caption="Category"&gt;category&lt;/FieldName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType="string"&gt;' + category["name"] + '&lt;/Value&gt;'
                + '&lt;/condition&gt;'
                + '&lt;condition logical=\"AND\" negate=\"false\"&gt;'
                + '&lt;operand type=\"variable\"&gt;'
                + '&lt;VariableName caption=\"$L.mode\"&gt;$L.action&lt;/VariableName&gt;'
                + '&lt;/operand&gt;'
                + '&lt;Comparison&gt;equals&lt;/Comparison&gt;'
                + '&lt;Value dataType=\"string\"&gt;reopen&lt;/Value&gt;&lt;/condition&gt;'
                + '&lt;/collection&gt;'
                + '&lt;/XmlCondition&gt;';
            closurePhase.altForm[idx2]["altFormCondDesc"] = '( Category in CurrentRecord = "' + category["name"] + '" AND $L.action = \"reopen\")';
            closurePhase.altForm[idx2]["altFormType"] = "disp";

            rc = category.getNext();
            idx++;
            idx2++;
        }
        loggingPhase.doAction("save");
        inProgressPhase.doAction("save");
        closurePhase.doAction("save");
    }

    system.functions.rtecall("trigger", ret, 0); //set trigger back to off
    printIt("Created Workflow \"" + pdMigratedWorkflowName + "\" for table \"" + tableName + ".", true);
}

/**
 * Create workflows according to the legacy phases in category
 */
function createDynamicWorkflowByCategories(objectNames) {
	var i;
    for(i=0, len=objectNames.length; i&lt;len; i++) {
        printIt("Creating workflows for Object \"" + objectNames[i] + "\"...", true);
        // 1, retrieve category table and phase table from object
        var obj = $("Object", SCFILE_READONLY).select("file.name=\"" + objectNames[i] + "\"").uniqueResult();
        if(null==obj) {
            printIt("Can not find object \"" + objectNames[i] + "\", ignore it.", true);
            continue;
        }
        if(null==obj["category.file.name"]) {
            printIt("The category table is not set for object \"" + objectNames[i] + "\", ignore it.", true);
            continue;
        }
        if(null==obj["phase.file.name"]) {
            printIt("The phase table is not set for object \"" + objectNames[i] + "\", ignore it.", true);
            continue;
        }

        // 2. create workflow for each category
        // 2.1 query category
        printIt("Creating workflows of category table \"" + obj["category.file.name"] + "\" for Object \"" + objectNames[i] + "\"...");
        var cat = new SCFile(obj["category.file.name"], SCFILE_READONLY);
        var rc = cat.doSelect('true');
        while(rc == RC_SUCCESS) {
            var workflow = new SCFile("Workflow");
			var filename = objectNames[i];
			var sql = "name=\"" + cat.name + "\" and tableName=\"" + filename + "\"";
			if (workflow.doSelect( sql ) != RC_SUCCESS) {
				workflow.name = cat.name;
				workflow.tableName = filename;
				workflow.description= cat.description + AUTO_UPGRADED_SUFFIX_IN_DESC;
				workflow.type = "standard";
				if(objectNames[i] == "ocml") {
				    workflow.defaultPhase = cat.phase;
				    workflow.firstPhase = cat.phase;
				} else {
				    workflow.defaultPhase = cat.phases[0];
				    workflow.firstPhase = cat.phases[0];
				}

				if (workflow.doInsert() == RC_SUCCESS) {
					createPhases(cat, workflow, obj);
				}
			} else {
			    printIt("The workflow \"" + cat.name + "\" has already been created for table \"" + filename + "\", ignore it.");
			    rc = cat.getNext();
                continue;
			}

            rc = cat.getNext();
        }

        printIt("Created workflows for Object \"" + objectNames[i] + "\".", true);
    }
}

function createPhases(cat, workflow, obj) {
	var lng = 1;
	if(obj["file.name"] != "ocml") {
	    cat.phases.length();
	}
	
	var i;
	for (i=0; i&lt;lng; i++) {
		var phase = new SCFile(obj["phase.file.name"]);
		var phaseName = null;
		if(obj["file.name"] != "ocml") {
		    phaseName = cat.phases[i];
		} else {
		    phaseName = cat.phase;
		}
		var sql = "name=\"" + phaseName + "\"";
		if(obj["file.name"] == "ocmq") {
		    sql += " and area=\"q\"";
		} else if(obj["file.name"] == "ocmo") {
		    sql += " and area=\"o\"";
		} else if(obj["file.name"] == "ocml") {
		    sql += " and area=\"l\"";
		}
		var next = i + 1;
		
		if (phase.doSelect(sql) == RC_SUCCESS) {
			/* donot understand what's the logic in change module
			var updOldPhase = false;
			if (phase.open_behavior == "prompt") {
				phase.open_behavior == "update";
				updOldPhase = true;
			}

			if (updOldPhase == true)
				phase.doUpdate();
			*/

			var wfPhase = new SCFile("WorkflowPhase");
			var wfpSQL= "workflowName=\"" + workflow.name + "\" and tableName=\"" + workflow.tableName + "\" and phaseName=\"" + phase.name + "\"";
			if(wfPhase.doSelect(wfpSQL) == RC_SUCCESS) {
			    printIt("The phase \"" + phaseName + "\" in workflow \"" + workflow.name + "\" already exists, ignore it!");
			    continue;
			}

			wfPhase.workflowName = workflow.name;
			wfPhase.tableName = workflow.tableName;
			wfPhase.phaseName = phase.name;
			wfPhase.phaseOrder = next;
			wfPhase.description = phase.description;
			wfPhase.active = true;
			if(system.functions.exists("approvals", phase)) {
			    wfPhase.approvals = phase.approvals;
			} else if(system.functions.exists("approval.groups", phase)) {
			    wfPhase.approvals = phase["approval.groups"];
			} else {
			    printIt("Neither field name approvals nor field name approval.groups exists in phase table \"" + obj["phase.file.name"] + "\", ignore setting the approval into PD workflow!");
			}
			if(system.functions.exists("alerts", phase)) {
			    wfPhase.alerts = phase.alerts;
			} else if(system.functions.exists("alert.names", phase)) {
			    wfPhase.alerts = phase["alert.names"];
			} else {
			    printIt("Neither field name alerts nor field name alert.names exists in phase table \"" + obj["phase.file.name"] + "\", ignore setting the alert into PD workflow!");
			}
            if(system.functions.exists("recalc.approvals", phase)) {
			    wfPhase.approvalsRecalc = phase.recalc_approvals;
			} else {
			    printIt("Field name recalc.approvals does not exist in phase table \"" + obj["phase.file.name"] + "\", ignore setting the recalc condition into PD workflow!");
			}
			if(system.functions.exists("reset.approvals", phase)) {
			    wfPhase.approvalsReset = phase.reset_approvals;
			} else {
			    printIt("Field name reset.approvals does not exist in phase table \"" + obj["phase.file.name"] + "\", ignore setting the reset condition into PD workflow!");
			}
			if(system.functions.exists("recalc.alerts", phase)) {
			    wfPhase.alertsRecalc = phase.recalc_alerts;
			} else if(system.functions.exists("reeval.alerts", phase)) {
			    wfPhase.alertsRecalc = phase.reeval_alerts;
			} else {
			    printIt("Neigher field name reeval.alerts, nor field name recalc.alerts exists in phase table \"" + obj["phase.file.name"] + "\", ignore setting the reset condition into PD workflow!");
			}
			if(system.functions.exists("reset.alerts", phase)) {
			    wfPhase.alertsReset = phase.reset_alerts;
			} else {
			    printIt("Field name reset.alerts does not exist in phase table \"" + obj["phase.file.name"] + "\", ignore setting the reset condition into PD workflow!");
			}

			var updateCondStr = "$L.tableAccess.update=true";
			// use new or update to authorize the first phase
			if ( i == 0 ) {
				updateCondStr = updateCondStr + " or $L.tableAccess.new=true";
			}
			if ( phase.upd_control != null ) {
				updateCondStr = updateCondStr + " and (" + system.functions.str( phase.upd_control ) + ")";
			}
			wfPhase.updateCond = system.functions.parse( updateCondStr );
			wfPhase.updateCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
					                                         &lt;operand type=\"expression\"&gt;&lt;Expression caption=\"\"&gt;\""+ 
					                                         updateCondStr+"\"&lt;/Expression&gt;\
					                                         &lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
			wfPhase.updateCondDesc = system.functions.str(updateCondStr);
			wfPhase.xCoordinate = 20 + ( i * 140 );
			wfPhase.yCoordinate = 60;

			var phaseClsControl = null;
			if(system.functions.exists("cls.control", phase)) {
			    phaseClsControl = phase.cls_control;
			} else if(system.functions.exists("cls.cond", phase)) {
			    phaseClsControl = phase.cls_cond;
			}
			if (lng&gt;1 &amp;&amp; cat.phases[next] != null) {
				wfPhase.manualTransition[0].mtToPhase  = cat.phases[next];
				wfPhase.manualTransition[0].mtOptionName = "nextphase";
				wfPhase.manualTransition[0].mtOptionLoc = 1;
				wfPhase.manualTransition[0].mtId = 1;
				
				if (phaseClsControl != null &amp;&amp; phaseClsControl != ""  &amp;&amp; system.functions.str(phaseClsControl) != "true") {
					var phase_cls_control = system.functions.str(phaseClsControl);

					if(phase_cls_control.indexOf("and approval.status in $L.file=\"approved\"")&lt;0){//if already added , will not add again
						phaseClsControl = system.functions.val(
					                             "("+system.functions.str(phaseClsControl)+
					                             ") and approval.status in $L.file=\"approved\"", 10);
					}
					wfPhase.manualTransition[0].mtCondition = system.functions.val( phaseClsControl,10);
					wfPhase.manualTransition[0].mtCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
					                                         &lt;operand type=\"expression\"&gt;&lt;Expression caption=\"\"&gt;\""+ 
					                                         system.functions.str( phaseClsControl )+"\"&lt;/Expression&gt;\
					                                         &lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
					wfPhase.manualTransition[0].mtCondDesc =  system.functions.str( phaseClsControl ) ;
				} else {
					wfPhase.manualTransition[0].mtCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\" &gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
															 &lt;operand type=\"field\"&gt;&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;\
															 &lt;FieldName caption=\"Approval Status\"&gt;approval.status&lt;/FieldName&gt;&lt;/operand&gt;\
															 &lt;Comparison&gt;equals&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;approved&lt;/Value&gt;\
															 &lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
					wfPhase.manualTransition[0].mtCondDesc = "( Approval Status in CurrentRecord= approved  )";
					wfPhase.manualTransition[0].mtCondition = system.functions.val("approval.status in $L.file=\"approved\"",10);									 
				}
				wfPhase.manualTransition[0].mtxCoordinate = 20 + ( i * 140 ) + 120;
				wfPhase.manualTransition[0].mtyCoordinate = 80;
				wfPhase.manualTransition[0].mtOption = lib.Workflow.getOptionNumber(wfPhase, 1);
			} else {
				var lastPhase = new SCFile( "WorkflowPhase" );
				lastPhase.workflowName = workflow.name;
				lastPhase.tableName = workflow.tableName;
				lastPhase.phaseName = "Closed";
				lastPhase.phaseOrder = next + 1;
				lastPhase.description = "Closed";
				lastPhase.active = false;
				lastPhase.updateCond = false;
				lastPhase.updateCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
					                                         &lt;operand type=\"expression\"&gt;&lt;Expression caption=\"\"&gt;\""+ 
					                                         system.functions.str( "false" )+"\"&lt;/Expression&gt;\
					                                         &lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
			    lastPhase.updateCondDesc = system.functions.str( "false" );
				lastPhase.xCoordinate = 20 + ( (i+1) * 140 );
				lastPhase.yCoordinate = 60;

				wfPhase.manualTransition[0].mtToPhase  = "Closed";
				wfPhase.manualTransition[0].mtOptionName = "close";
				wfPhase.manualTransition[0].mtOptionLoc = 1;
				wfPhase.manualTransition[0].mtId = 1;
				wfPhase.manualTransition[0].mtCondition = phaseClsControl;
				wfPhase.manualTransition[0].mtRules[0] = "chm.task.close.status";
				
				if ( phaseClsControl != null &amp;&amp; phaseClsControl != ""  &amp;&amp; system.functions.str(phaseClsControl) != "true" ) {
				    var phase_cls_control = system.functions.str(phaseClsControl);
					
					if(phase_cls_control.indexOf("and approval.status in $L.file=\"approved\"")&lt;0){//if already added , will not add again
						phaseClsControl = system.functions.val(
					                             "("+system.functions.str(phaseClsControl)+
					                             ") and approval.status in $L.file=\"approved\"", 10);
					}
					wfPhase.manualTransition[0].mtCondition = system.functions.val(phaseClsControl,10);
					wfPhase.manualTransition[0].mtCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
					                                         &lt;operand type=\"expression\"&gt;&lt;Expression caption=\"\"&gt;\""+ 
					                                         system.functions.str( phaseClsControl )+"\"&lt;/Expression&gt;\
					                                         &lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
					wfPhase.manualTransition[0].mtCondDesc = system.functions.str( phaseClsControl );
				} else {
					wfPhase.manualTransition[0].mtCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\" &gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
															 &lt;operand type=\"field\"&gt;&lt;TableName&gt;CurrentRecord&lt;/TableName&gt;\
															 &lt;FieldName caption=\"Approval Status\"&gt;approval.status&lt;/FieldName&gt;&lt;/operand&gt;\
															 &lt;Comparison&gt;equals&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;approved&lt;/Value&gt;\
															 &lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
					wfPhase.manualTransition[0].mtCondDesc = "( Approval Status in CurrentRecord= approved  )";
					wfPhase.manualTransition[0].mtCondition = system.functions.val("approval.status in $L.file=\"approved\"",10);									 
				}

				wfPhase.manualTransition[0].mtOption = lib.Workflow.getOptionNumber( wfPhase, 1 );
				wfPhase.manualTransition[0].mtxCoordinate = 20 + ( i * 140 ) + 120;
				wfPhase.manualTransition[0].mtyCoordinate = 80;

				// Add a reopen option to last phase
				lastPhase.manualTransition[0].mtToPhase  = phase.name;
				lastPhase.manualTransition[0].mtOptionName = "reopen";
				lastPhase.manualTransition[0].mtOptionLoc = 1;
				lastPhase.manualTransition[0].mtId = 1;

				var localName = null;
				var scmsg = $("scmessage").select("syslanguage=\"en\" and class=\"tablename\" and message.id=\"" + obj["file.name"] + "\"").uniqueResult();
                if(null == scmsg) {
                    printIt("Can not found the english table name of object \"" + obj["file.name"] + "\", use object name directly!");
                    localName = obj["file.name"];
                } else {
                    localName = scmsg.message;
                }
				lastPhase.manualTransition[0].mtCondition = system.functions.val("jscall(\"security.getToken\",\"" + localName + "\",\"reopen\")=\"true\"",10);
				lastPhase.manualTransition[0].mtCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\" &gt;&lt;condition logical=\"\" negate=\"false\"&gt;\
															 &lt;operand type=\"security\"&gt;&lt;Area caption=\"" + localName + "\"&gt;" + localName + "&lt;/Area&gt;&lt;Right caption=\"Reopen\"&gt;reopen&lt;/Right&gt;\
															 &lt;/operand&gt;&lt;Comparison&gt;equals&lt;/Comparison&gt;&lt;Value dataType=\"string\"&gt;true&lt;/Value&gt;&lt;/condition&gt;\
															 &lt;/collection&gt;&lt;/XmlCondition&gt;";
				lastPhase.manualTransition[0].mtCondDesc = "( Reopen in " + localName + " = true  )";
				
				lastPhase.manualTransition[0].mtOption = lib.Workflow.getOptionNumber(wfPhase, 1);
				lastPhase.manualTransition[0].mtxCoordinate = 70 + ( (i+1) * 140 ) ;
				lastPhase.manualTransition[0].mtyCoordinate = 140;

				// check if the WorkflowPhase exists
				var checkLastPhase = new SCFile("WorkflowPhase");
				if (checkLastPhase.doSelect("phaseName=\"" + lastPhase.phaseName + "\" and workflowName=\"" + lastPhase.workflowName + "\" and tableName=\"" + lastPhase.tableName + "\"") != RC_SUCCESS) {
					lastPhase.doInsert();
				}

				var rmessage = new SCFile( "scmessage" );
				var rmsql = "class=\"wfT\" and message.id=\""+lastPhase.phaseName+"_"+wfPhase.workflowName+"_"+wfPhase.tableName+":1\"";

				if ( rmessage.doSelect( rmsql ) == RC_SUCCESS ) {
					rmessage.message = "Reopen";
					rmessage.doUpdate();
				} else {
					rmessage._class="wfT";
					rmessage.message_id=lastPhase.phaseName+"_"+wfPhase.workflowName+"_"+wfPhase.tableName+":1";
					rmessage.message = "Reopen";
					rmessage.doInsert();
				}
			}
			
			// check if the WorkflowPhase exists
			var checkPhase = new SCFile( "WorkflowPhase" );
			if (checkPhase.doSelect("phaseName=\"" + wfPhase.phaseName + "\" and workflowName=\"" + wfPhase.workflowName + "\" and tableName=\"" + wfPhase.tableName + "\"") != RC_SUCCESS) {
				var rc = wfPhase.doInsert();
			}
			var message = new SCFile( "scmessage" );
			var msql = "class=\"wfT\" and message.id=\""+wfPhase.phaseName+"_"+wfPhase.workflowName+"_"+wfPhase.tableName+":1\"";
			
			if ( message.doSelect( msql ) == RC_SUCCESS ) {
				if (lng&gt;1 &amp;&amp; cat.phases[next] != null) {
					message.message = "Next Phase";
				}
				else {
					message.message = "Close";
				}
				message.doUpdate();
			} else {
				message._class="wfT";
				message.message_id=wfPhase.phaseName+"_"+wfPhase.workflowName+"_"+wfPhase.tableName+":1";
				if (lng&gt;1 &amp;&amp; cat.phases[next] != null ) {
					message.message = "Next Phase";
				}
				else {
					message.message = "Close";
				}
				message.doInsert();
			}
			
			var localmessage = new SCFile("scmessage");
			msql = "class=\"local:WorkflowPhase\" and message.id=\""+wfPhase.phaseName+";"+wfPhase.workflowName+";"+wfPhase.tableName+"\"";
			
			if ( localmessage.doSelect( msql ) == RC_SUCCESS ) {
				localmessage.message = wfPhase.phaseName;
				message.doUpdate();
			} else {
				localmessage._class="local:WorkflowPhase";
				localmessage.message_id=wfPhase.phaseName+";"+wfPhase.workflowName+";"+wfPhase.tableName;
				localmessage.message = wfPhase.phaseName;
				localmessage.doInsert();
			}
		} else {
		    printIt("Canot find phase \"" + phaseName + "\" in phase table \"" + obj["phase.file.name"] + "\", ignore it!");
		    continue;
		}
		phase.doUpdate();
	}
}

/**
 * Add Workflow.
 * 
 * @param {HashMap} workflow_body
 *         workflow_body = {
 *            "name": "TestJSWorkflow",
 *            "tableName": "MigrationSourceTable",
 *            "defaultPhase": "Phase 1",
 *            "firstPhase": "Phase 1" }
 *
 * @return the Workflow record.
 */
function addWorkflow(workflow_body) {
    var workflow = new SCFile("Workflow");
    var field;
    for(field in workflow_body) {
        workflow[field] = workflow_body[field];
    }
    workflow.doAction("add");
    addMigrationPatchRecord("Workflow", workflow, workflow["name"], false);
    return workflow;
}

/**
 * Add Workflow Phase.
 * 
 * @param {HashMap} phase_body
 *         var phase_body = { 
 *            "phaseName": "Phase 1",
 *            "workflowName": "TestJSWorkflow",
 *            "tableName": "MigrationSourceTable",
 *            "active": true }
 * 
 * @return WorkflowPhase record.
 * @type object
 */
function addWorkflowPhase(phase_body) {
    var workflowPhase = new SCFile("WorkflowPhase");
    var field;
    for (field in phase_body) {
        workflowPhase[field] = phase_body[field];
    }
    workflowPhase.doAction("add");
    addMigrationPatchRecord("WorkflowPhase", workflowPhase, workflowPhase["name"], false);
    return workflowPhase;
}

/**
 * Add Manual Transition into the specified Workflow Phase.
 * 
 * @param {String}
 *            phaseName - The Workflow Phase Name
 * @param {String}
 *            workflowName - The workflow name
 * @param {String}
 *            tablename - The Workflow table name
 * @param {HashMap}
 *            trasition_body - The transition content var transition_body = {
 *            "mtToPhase": "Phase 2", // The tranistion target phase
 *            "mtOptionName": "Next Phase", // The Command Name "mtOptionLoc":
 *            2, // The Command Location: 1 - "Tray", 2 - "More Option List", 3 -
 *            "Button" "mtOption": 60 }
 * @param {String}
 *            type - Which type transition want to add. Value has: "auto",
 *            "manual".
 * 
 * @return WorkflowPhase record.
 * @type object
 */
function addManualTransition(phaseName, workflowName, tableName,
        transition_body) {
    var workflowPhase = new SCFile("WorkflowPhase");
    var query = "phaseName=\"" + phaseName + "\" and tableName=\"" + tableName
            + "\" and workflowName=\"" + workflowName + "\"";
    workflowPhase.doSelect(query);

    var transitionType = "manualTransition";
    var transitions = workflowPhase[transitionType];
    var transitionsLen = transitions.length();

	var field;
    if (transitions[0] == null) {
        for (field in transition_body) {
            workflowPhase[transitionType][0][field] = transition_body[field];
        }
    } else {
        for (field in transition_body) {
            workflowPhase[transitionType][transitionsLen][field] = transition_body[field];
        }
    }
    workflowPhase.doAction("save");
    return workflowPhase;
}

/**
 * Add Auto Transition into the specified Workflow Phase.
 * 
 * @param {String}
 *            phaseName - The Workflow Phase Name
 * @param {String}
 *            workflowName - The workflow name
 * @param {String}
 *            tablename - The Workflow table name
 * @param {HashMap}
 *            trasition_body - The transition content var transition_body = {
 *            "atToPhase": "Phase 2", // The tranistion target phase
 * 
 * @return WorkflowPhase record.
 * @type object
 */
function addAutoTransition(phaseName, workflowName, tableName, transition_body) {
    var workflowPhase = new SCFile("WorkflowPhase");
    var query = "phaseName=\"" + phaseName + "\" and tableName=\"" + tableName
            + "\" and workflowName=\"" + workflowName + "\"";
    var ret = workflowPhase.doSelect(query);

    var transitionType = "autoTransition";
    var transitions = workflowPhase[transitionType];
    var transitionsLen = transitions.length();

    var oldworkflowphase = workflowPhase;

	var field;
    if (transitions[0] == null) {
        for (field in transition_body) {
            workflowPhase[transitionType][0][field] = transition_body[field];
        }
    } else {
        for (field in transition_body) {
            workflowPhase[transitionType][transitionsLen][field] = transition_body[field];
        }
    }
    workflowPhase.doAction("save");
    return workflowPhase;
}

/**
 * Add Default Transition into the specified Workflow Phase.
 * 
 * @param {String}
 *            phaseName - The Workflow Phase Name
 * @param {String}
 *            workflowName - The workflow name
 * @param {String}
 *            tablename - The Workflow table name
 * @param {HashMap}
 *            trasition_body - The transition content var transition_body = {
 *            "toPhase": "Phase 2" // The tranistion target phase
 * 
 * @return WorkflowPhase record.
 * @type object
 */
function addDefaultTransition(phaseName, workflowName, tableName, transition_body) {
    var workflowPhase = new SCFile("WorkflowPhase");
    var query = "phaseName=\"" + phaseName + "\" and tableName=\"" + tableName
            + "\" and workflowName=\"" + workflowName + "\"";
    var ret = workflowPhase.doSelect(query);

    workflowPhase["defaultTransition"] = transition_body["toPhase"];
    workflowPhase.doAction("save");
    return workflowPhase;
}

/**
 * This method is only used for test purpose to rollback the ENV to the init state after PD enablement,
 * then we can continue to test.
 */
function cleanup() {
    // 1. clean up Objects
    var i;
    for(i=0, len=OBJECT_NAMES.length; i&lt;len; i++) {
        // check diabled by PD migration records
        var objectFile = $("Object").select("file.name=\"" + OBJECT_NAMES[i] + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
        if (null!==objectFile) {
            // if found, delete the current using record
            var objectFileUsing = $("Object").select("file.name=\"" + OBJECT_NAMES[i] + "\"").uniqueResult();
            if (null!==objectFileUsing) {
                objectFileUsing.doDelete();
            }
            // and then rollback the finding disabled one by PD migration to using record
            objectFile["file.name"] = OBJECT_NAMES[i];
            objectFile.doUpdate();
        }
    }
    //2. clean up Workflows
    //2.1 delete the default incident and service desk workflows
    deleteWorkflow("probsummary", PD_CODE_MIGRATION_WF_PREFIX + "Incident");
    deleteWorkflow("incidents", PD_CODE_MIGRATION_WF_PREFIX + "ServiceDesk");
    //2.2 delete ...
    //2.x rollback disabled OOB workflows
}

function deleteWorkflow(tableName, workflowName) {
    var workflow = new SCFile("Workflow");
    var rc = workflow.doSelect('tableName="' + tableName + '" and name="' + workflowName + '"');
    while(rc == RC_SUCCESS) {
            var orgName = workflow["name"];
            // rename the workflow name in workflow phases
            var phases = new SCFile("WorkflowPhase");
            var rc2 = phases.doSelect('tableName="' + tableName + '" and workflowName="' + workflowName + '"');
            while(rc2 == RC_SUCCESS) {
                phases.doDelete();
                rc2 = phases.getNext();
            }
            // rename the workflow name itself to disabled one
            workflow.doDelete();
            printIt("Removed the workflow \"" + workflowName + "\".");
        rc = workflow.getNext();
    }
}

function migrateCategories() {
    printIt("Start migrating Categories...", true);
    //1. migrate Incident/ServiceDesk categories
    migrateIncidentCategories();

    //2. migrate legacy request categories
    migrateRequestCategories();

    printIt("Finish migrating Categories.", true);
}

function prepareCategories2Migrate() {
    var sdCatSelected = [],
        imCatSelected = [],
        pmCatSelected = [],
        allCat = [];

    var category = new SCFile("category");
    var rc = category.doSelect('true');
    while (rc == RC_SUCCESS) {
        if (category.name == "problem") {
            pmCatSelected.push(category.name);
        } else if (category.name == "service catalog") {
            sdCatSelected.push(category.name);
        } else if (category.name == "incident" || category.name == "request for information"|| category.name == "request for change" || category.name == "complaint") {
            sdCatSelected.push(category.name);
            imCatSelected.push(category.name);
        } else if (!(_str.startsWith(category.name, "NEW") || _str.startsWith(category.name, "OLD") || _str.startsWith(category.name, "PRE")) &amp;&amp; category.active) {
            sdCatSelected.push(category.name);
            imCatSelected.push(category.name);
            pmCatSelected.push(category.name);
        }
        allCat.push(category.name);
        rc = category.getNext();
    }

    vars['$sdcat2migrate.selected'] = sdCatSelected;
    vars['$imcat2migrate.selected'] = imCatSelected;
    vars['$pmcat2migrate.selected'] = pmCatSelected;
    vars['$cat2migrate'] = allCat;
}


function prepareCategories2MigrateByDesc() {
    var sdCatSelected = [],
        imCatSelected = [],
        pmCatSelected = [],
        allCat = [];


    var category = new SCFile("sdCategory");
    var rc = category.doSelect('true');
    while (rc == RC_SUCCESS) {
        if (_.endsWith(category.description, AUTO_UPGRADED_SUFFIX_IN_DESC)) {
            sdCatSelected.push(category.name);
        }
        rc = category.getNext();
    }

    var category = new SCFile("imCategory");
    var rc = category.doSelect('true');
    while (rc == RC_SUCCESS) {
        if (_.endsWith(category.description, AUTO_UPGRADED_SUFFIX_IN_DESC)) {
            imCatSelected.push(category.name);
        }
        rc = category.getNext();
    }

    var category = new SCFile("pbmCategory");
    var rc = category.doSelect('true');
    while (rc == RC_SUCCESS) {
        if (_.endsWith(category.description, AUTO_UPGRADED_SUFFIX_IN_DESC)) {
            pmCatSelected.push(category.name);
        }
        rc = category.getNext();
    }

    vars['$sdcat2migrate.selected'] = sdCatSelected;
    vars['$imcat2migrate.selected'] = imCatSelected;
    vars['$pmcat2migrate.selected'] = pmCatSelected;
}


/**
 * Incident and Service Desk category, both are from category table.
 * During upgrade,the function called in both testing Env and production Env, need diffrent logic.
 *  @param 	{String} 	callInProduction 	        -  flag about whether function is called in production
 */
function migrateIncidentCategories(callInProduction) {
    //0. check any new fields in customer's legacy category dbdict, and auto add to pd category dbdict.
    //   menwhile also check the keys, for e.g., the whether the unique key has more fields (like company field).
    //   -- unique key has more fields does not handle here, the company as unique is added in OOB.
    //   also need to compare the field length, enlarge the pd category dbdict fields if necessary
    var oobCategoryFields = ["name", "activity", "open.format", "update.format", "close.format", "count",
	 "alert1", "alert2", "alert3", "reassign", "default.assign", "avail.post",
	 "qbe.format", "dl.alert", "dl.group", "alert1.expression", "alert2.expression",
	 "alert3.expression", "dl.expression", "reass.expression", "print.override", "print.open",
	 "print.open.format", "print.update", "print.update.format", "print.close", 
	 "print.close.format", "alert.pages", "initial.format", "check.duplicates", 
	 "check.parents", "device.types", "include.unexpired", "expires.after", 
	 "script", "browse.format", "review.print.formats", "open.print.formats", 
	 "update.print.formats", "close.print.formats", "assignment.expression", 
	 "category.format", "wdClsDuration", "wdUD1", "wdUD2", "wdPriority", 
	 "wdClsCustSatisfaction", "wdClsActDuration", "wdClsRoot", "wdClsLevel", 
	 "wdClsParent", "wdClsInflatePriority", "wdClsTimeStamp", "wdTips", "print.format", 
	 "active", "sysmodcount", "sysmoduser", "sysmodtime", "copy.open.link", "company", 
	 "engine.alerts", "approvals"];
    var categoryFieldsMapping = {// the mapping fields from PD category to non-PD category fields for character type which will be used to enlarge the length if necessary
      name:"name",
      company:"company"
      };
    if (!callInProduction) { //Do not run in product,dbdict is ready in testing and applied to production 
    var addedFieldsOfCategory = lib.PDCodeMigrationUtil.migrateDbdict("category", "imCategory", oobCategoryFields, categoryFieldsMapping);
    lib.PDCodeMigrationUtil.migrateDbdict("category", "sdCategory", oobCategoryFields, categoryFieldsMapping);
    lib.PDCodeMigrationUtil.enlargeFieldLength("pbmCategory", "description", 250);
    lib.PDCodeMigrationUtil.migrateDbdict("category", "pbmCategory", oobCategoryFields, categoryFieldsMapping);
    var oobSubcategoryFields = ["category", "subcategory", "subcategory.name", "description", "company",
      "active", "sysmodcount", "sysmoduser", "sysmodtime"];
    var subcategoryFieldsMapping = {// the mapping fields from PD category to non-PD category fields for character type which will be used to enlarge the length if necessary
      "subcategory.name":"subcategory",
      "name":"subcategory",//this is only added for sdSucategory as it's field name is name rather than subcategory.name in pbmSubcategory and imSubcategory
      category:"category",
      company:"company"
     };
    var addedFieldsOfSubcategory = lib.PDCodeMigrationUtil.migrateDbdict("subcategory", "imSubcategory", oobSubcategoryFields, subcategoryFieldsMapping);
    lib.PDCodeMigrationUtil.migrateDbdict("subcategory", "sdSubcategory", oobSubcategoryFields, subcategoryFieldsMapping);
    lib.PDCodeMigrationUtil.migrateDbdict("subcategory", "pbmSubcategory", oobSubcategoryFields, subcategoryFieldsMapping);
    var oobAreaFields = ["category", "subcategory", "product.type", "description", "company", "active", "sysmodcount", "sysmodtime", "sysmoduser"];
    var areaFieldsMapping = {// the mapping fields from PD category to non-PD category fields for character type which will be used to enlarge the length if necessary
      "area.name":"product.type",
      subcategory:"subcategory",
      category:"category",
      company:"company"
      };
    var addedFieldsOfArea = lib.PDCodeMigrationUtil.migrateDbdict("producttype", "imArea", oobAreaFields, areaFieldsMapping);
    lib.PDCodeMigrationUtil.enlargeFieldLength("sdArea", "description", 250);
    lib.PDCodeMigrationUtil.migrateDbdict("producttype", "sdArea", oobAreaFields, areaFieldsMapping);
    lib.PDCodeMigrationUtil.migrateDbdict("producttype", "pbmArea", oobAreaFields, areaFieldsMapping);
    }

    //1. clean up the PD category tables (sdCategory and imCategory)
    if (!callInProduction) { //Do not run in product,conflict PD category already renamed in testing and moved to produciton.         
    if(OPTION==OPT2) {
        renameOOBCategoryIfConflict();
    } else {
	    deleteRecords("sdCategory", 'true');
	    deleteRecords("sdSubcategory", 'true');
	    deleteRecords("sdArea", 'true');
	    deleteRecords("imCategory", 'true');
	    deleteRecords("imSubcategory", 'true');
	    deleteRecords("imArea", 'true');
	    deleteRecords("pbmCategory", 'true');
	    deleteRecords("pbmSubcategory", 'true');
	    deleteRecords("pbmArea", 'true');
	}
    }

    //1.1. prepare the categories to be migrated.
    if (!vars['$cat2migrate']) {
        if (callInProduction) //In production, we get the list of categories migrated by its description
        {
            prepareCategories2MigrateByDesc();
        } else {
        prepareCategories2Migrate();
        }
    }
    var sdcat2Migrate = vars['$sdcat2migrate.selected'].toArray();
    var imcat2Migrate = vars['$imcat2migrate.selected'].toArray();
    var pmcat2Migrate = vars['$pmcat2migrate.selected'].toArray();

	//1.2. calculate shareflag of the categoires to be migrated.
    var shareFlags = {};
    var catArrs = [sdcat2Migrate, imcat2Migrate, pmcat2Migrate];
    var weights = [1, 2, 4];
    var i,j;
    for (i = 0; i &lt; catArrs.length; ++i) {
        for (j = 0; j &lt; catArrs[i].length; ++j) {
            var catName = catArrs[i][j];
            if (catName) {
                shareFlags[catName] = shareFlags[catName] ? shareFlags[catName] + weights[i] : weights[i];
            }
        }
    }
    var shareFlagMap = {
        1: 0, //interaction only
        2: 1, //Incident only
        3: 3, //SD&amp;IM
        4: 2, //PM only
        5: 5, //SD &amp;PM
        6: null, //IM&amp;PM,not valid
        7: 4 //SD&amp;IM&amp;PM
    };
    var catIndex;
    for (catIndex in shareFlags) {
        shareFlags[catIndex] = shareFlagMap[shareFlags[catIndex]];
    }

    // set trigger on to make sure the related scmsg for name localization could be auto generated
    var ret = 0;
	system.functions.rtecall("trigger", ret, 1);

    //2. add into PD category tables
    var item;    
    var changedFiles = [];
    if (!callInProduction) //Do not run in product,categoies already migrated in testing Env and moved to production
    {
    var category = new SCFile("category");
    var rc = category.doSelect('true');
    while(rc == RC_SUCCESS) {
        
        if (lib.ArrayUtil.contains(imcat2Migrate, category.name)) {
	        printIt("Adding category \"" + category.name + "\" to table \"imCategory\"...");
	        changedFiles.push(category.name);
	        var imCategory = new SCFile("imCategory");
	        imCategory.name = category.name;
            imCategory.sharedflag = shareFlags[category.name];
	        imCategory.active = category.active;
	        imCategory.avail_post = category.avail_post;
	        imCategory.description = category.name + AUTO_UPGRADED_SUFFIX_IN_DESC;
	        imCategory.workflow = PD_CODE_MIGRATION_WF_PREFIX + "Incident";
	        imCategory.company = category.company;
	        for(item in addedFieldsOfCategory) {
	
	            imCategory[item] = category[item];
	        }
	        imCategory.doInsert();
            addMigrationPatchRecord("imCategory", imCategory, imCategory["name"], false);
	        printIt("Added category \"" + category.name + "\" to table \"imCategory\".");
        }
        
        if (lib.ArrayUtil.contains(sdcat2Migrate, category.name)) {
	        printIt("Adding category \"" + category.name + "\" to table \"sdCategory\"...");
	        var sdCategory = new SCFile("sdCategory");
	        sdCategory.name = category.name;
            sdCategory.sharedflag = shareFlags[category.name];
	        sdCategory.active = category.active;
	        //for the shared cateogry, set allow escalate default as true.
	        sdCategory.escalate = (sdCategory.sharedflag==3||sdCategory.sharedflag==5||sdCategory.sharedflag==4)?true:null;
	        sdCategory.description = category.name + AUTO_UPGRADED_SUFFIX_IN_DESC;
	        sdCategory.workflow = PD_CODE_MIGRATION_WF_PREFIX + "ServiceDesk";
	        sdCategory.approvals = category.approvals;
	        sdCategory.company = category.company;
	        for(item in addedFieldsOfCategory) {
	            sdCategory[item] = category[item];
	        }
	        sdCategory.doInsert();
            addMigrationPatchRecord("sdCategory", sdCategory, sdCategory["name"], false);
	        printIt("Added category \"" + category.name + "\" to table \"sdCategory\"...");
        }
        if (lib.ArrayUtil.contains(pmcat2Migrate, category.name)) {
	        printIt("Adding category \"" + category.name + "\" to table \"pbmCategory\"...");
	        var pbmCategory = new SCFile("pbmCategory");
	        pbmCategory.name = category.name;
            pbmCategory.sharedflag = shareFlags[category.name];
            pbmCategory.active = pbmCategory.name=="problem"?true:category.active;
	        pbmCategory.description = category.name + AUTO_UPGRADED_SUFFIX_IN_DESC;
	        pbmCategory.workflow = "Problem";
	        pbmCategory.company = category.company;
	        for(item in addedFieldsOfCategory) {
	            pbmCategory[item] = category[item];
	        }
	        pbmCategory.doInsert();
            addMigrationPatchRecord("pbmCategory", pbmCategory, pbmCategory["name"], false);
	        printIt("Added category \"" + category.name + "\" to table \"pbmCategory\"...");
        }

        rc = category.getNext();
    }
    var reportObj = {};
    reportObj.title = "The following category records and their corresponding subcategory/producttype records" + " are migrated to the Process Designer-based Incident related category tables(imCategory,imSubcategory and imArea)." + "Meanwhile the conflicted Process Designer-based OOB category records are renamed with suffix \"" + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\":";
    reportObj.files = imcat2Migrate;
    reportObj.needManualCheck = false;
    reportObj.category="Category";
    reportObj.filename="category";
    
    SUMMARY_REPORT_OBJS.push(reportObj);
    reportObj = {};
    reportObj.title = "The following category records and their subcategory/producttype records" + " are migrated to the Process Designer-based Interaction related category tables(sdCategory,sdSubcategory and sdArea)." + "Meanwhile the conflicted Process Designer-based OOB category records are renamed with suffix \"" + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\":";
    reportObj.files = sdcat2Migrate;
    reportObj.needManualCheck = false;
    reportObj.category="Category";
    reportObj.filename="category";
    
    SUMMARY_REPORT_OBJS.push(reportObj);
    reportObj = {};
    reportObj.title = "The following category records and their subcategory/producttype records" + " are migrated to the Process Designer-based Problem related category tables(pbmCategory,pbmSubcategory and pbmArea)." + "Meanwhile the conflicted Process Designer-based OOB category records are renamed with suffix \"" + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\":";
    reportObj.files = pmcat2Migrate;
    reportObj.needManualCheck = false;
    reportObj.category="Category";
    reportObj.filename="category";

    SUMMARY_REPORT_OBJS.push(reportObj);
    }

    //3. add into PD subcategory tables
    var subcategory = new SCFile("subcategory");
    var rc = subcategory.doSelect('true');
    while(rc == RC_SUCCESS) {

        if (lib.ArrayUtil.contains(imcat2Migrate, subcategory.category)) {
        printIt("Adding subcategory \"" + subcategory.subcategory + "\" to table \"imSubcategory\"...");
        var imSubcategory = new SCFile("imSubcategory");
        imSubcategory.subcategory_name = subcategory.subcategory;
        imSubcategory.category = subcategory.category;
            imSubcategory.sharedflag = shareFlags[subcategory.category];
        imSubcategory.active = subcategory.active;
        imSubcategory.description = subcategory.subcategory + AUTO_UPGRADED_SUFFIX_IN_DESC;
        imSubcategory.company = subcategory.company;
        for(item in addedFieldsOfSubcategory) {
            imSubcategory[item] = subcategory[item];
        }
            imSubcategory.doSave(); //Use doSave instead of doInsert, in Production, the subcategory may already migrated in testing Env and moved to production
            addMigrationPatchRecord("imSubcategory", imSubcategory, imSubcategory.subcategory_name, false);
        printIt("Added subcategory \"" + subcategory.subcategory + "\" to table \"imSubcategory\".");
        }
        if (lib.ArrayUtil.contains(sdcat2Migrate, subcategory.category)) {
        printIt("Adding subcategory \"" + subcategory.subcategory + "\" to table \"sdSubcategory\"...");
        var sdSubcategory = new SCFile("sdSubcategory");
        sdSubcategory.name = subcategory.subcategory;
        sdSubcategory.category = subcategory.category;
        sdSubcategory.sharedflag = shareFlags[subcategory.category];
        sdSubcategory.active = subcategory.active;
        sdSubcategory.description = subcategory.subcategory + AUTO_UPGRADED_SUFFIX_IN_DESC;
        sdSubcategory.company = subcategory.company;
        for(item in addedFieldsOfSubcategory) {
            sdSubcategory[item] = subcategory[item];
        }
            sdSubcategory.doSave();
            addMigrationPatchRecord("sdSubcategory", sdSubcategory, sdSubcategory.name, false);
        printIt("Added subcategory \"" + subcategory.subcategory + "\" to table \"sdSubcategory\"...");
        }
        if (lib.ArrayUtil.contains(pmcat2Migrate, subcategory.category)) {
        printIt("Adding subcategory \"" + subcategory.subcategory + "\" to table \"pbmSubcategory\"...");
        var pbmSubcategory = new SCFile("pbmSubcategory");
        pbmSubcategory.subcategory_name = subcategory.subcategory;
        pbmSubcategory.category = subcategory.category;
        pbmSubcategory.sharedflag = shareFlags[subcategory.category];
        pbmSubcategory.active = subcategory.active;
        pbmSubcategory.description = subcategory.subcategory + AUTO_UPGRADED_SUFFIX_IN_DESC;
        pbmSubcategory.company = subcategory.company;
        for(item in addedFieldsOfSubcategory) {
            pbmSubcategory[item] = subcategory[item];
        }
            pbmSubcategory.doSave();
            addMigrationPatchRecord("pbmSubcategory", pbmSubcategory, pbmSubcategory.subcategory_name, false);
        printIt("Added subcategory \"" + subcategory.subcategory + "\" to table \"pbmSubcategory\"...");
        }

        rc = subcategory.getNext();
    }

    //4. add into PD area tables
    var producttype = new SCFile("producttype");
    var rc = producttype.doSelect('true');
    while(rc == RC_SUCCESS) {

        if (lib.ArrayUtil.contains(imcat2Migrate, producttype.category)) {
        printIt("Adding area \"" + producttype.product_type + "\" to table \"imArea\"...");
        var imArea = new SCFile("imArea");
        imArea.area_name = producttype.product_type;
        imArea.category = producttype.category;
        imArea.subcategory = producttype.subcategory;
            imArea.sharedflag = shareFlags[producttype.category];
        imArea.active = producttype.active;
        imArea.description = producttype.product_type + AUTO_UPGRADED_SUFFIX_IN_DESC;
        imArea.company = producttype.company;
        for(item in addedFieldsOfArea) {
            imArea[item] = producttype[item];
        }
            imArea.doSave();
            addMigrationPatchRecord("imArea", imArea, imArea.area_name, false);
        printIt("Added area \"" + producttype.product_type + "\" to table \"imArea\".");
        }
        if (lib.ArrayUtil.contains(sdcat2Migrate, producttype.category)) {
        printIt("Adding area \"" + producttype.product_type + "\" to table \"sdArea\"...");
        var sdArea = new SCFile("sdArea");
        sdArea.area_name = producttype.product_type;
        sdArea.category = producttype.category;
        sdArea.subcategory = producttype.subcategory;
            sdArea.sharedflag = shareFlags[producttype.category];
        sdArea.active = producttype.active;
        sdArea.description = producttype.product_type + AUTO_UPGRADED_SUFFIX_IN_DESC;
        sdArea.company = producttype.company;
        for(item in addedFieldsOfArea) {
            sdArea[item] = producttype[item];
        }
            sdArea.doSave();
            addMigrationPatchRecord("sdArea", sdArea, sdArea.area_name, false);
        printIt("Added area \"" + producttype.product_type + "\" to table \"sdArea\"...");
        }
        if (lib.ArrayUtil.contains(pmcat2Migrate, producttype.category)) {
        printIt("Adding area \"" + producttype.product_type + "\" to table \"pbmArea\"...");
        var pbmArea = new SCFile("pbmArea");
        pbmArea.area_name = producttype.product_type;
        pbmArea.category = producttype.category;
        pbmArea.subcategory = producttype.subcategory;
        pbmArea.sharedflag = shareFlags[producttype.category];
        pbmArea.active = producttype.active;
        pbmArea.description = producttype.product_type + AUTO_UPGRADED_SUFFIX_IN_DESC;
        pbmArea.company = producttype.company;
        for(item in addedFieldsOfArea) {
            pbmArea[item] = producttype[item];
        }
            pbmArea.doSave();
            addMigrationPatchRecord("pbmArea", pbmArea, pbmArea.area_name, false);
        printIt("Added area \"" + producttype.product_type + "\" to table \"pbmArea\"...");
        }

        rc = producttype.getNext();
    }
    system.functions.rtecall("trigger", ret, 1);// set trigger back to off

    //5. auto check mandaten setting for category tables
    var mandantenMap = {
        "category":["imCategory", "sdCategory", "pbmCategory"],
        "subcategory":["imSubcategory", "sdSubcategory", "pbmSubcategory"],
        "producttype":["imArea", "sdArea", "pbmArea"],
    };
    migrationMandaten(mandantenMap);
}

/**
 * Legacy request category.
 */
function migrateRequestCategories() {
    printIt("Start migrating request categories...", true);
    var fieldObjects = [
        {
            "level":1,
            "name":"workflow",
            //"type":lib.DataTypeConst.typeCharacter,
            "type":2,
            "len":40
        }
    ];
    for(var i=0, len=REQUEST_OBJECT_NAMES.length; i&lt;len; i++) {
        // 1, upddate dbdict to add workflow field
        printIt("Adding workflow field to Object \"" + REQUEST_OBJECT_NAMES[i] + "\"'s category table...");
        var obj = $("Object", SCFILE_READONLY).select("file.name=\"" + REQUEST_OBJECT_NAMES[i] + "\"").uniqueResult();
        if(null==obj) {
            printIt("Can not find object \"" + REQUEST_OBJECT_NAMES[i] + "\", ignore it.");
            continue;
        }
        if(null==obj["category.file.name"]) {
            printIt("The category table is not set for object \"" + REQUEST_OBJECT_NAMES[i] + "\", ignore it.");
            continue;
        }
        printIt("Adding the workflow field to category table \"" + obj["category.file.name"] + "\" for object \"" + REQUEST_OBJECT_NAMES[i] + "\"...");
        addFieldsToDbdict(obj["category.file.name"], fieldObjects);

        // 2. update category records to set workflow name value
        printIt("Updating records of category table \"" + obj["category.file.name"] + "\" to set workflow...");
        var cat = new SCFile(obj["category.file.name"]);
        var rc = cat.doSelect('true');
        while(rc == RC_SUCCESS) {
            cat.workflow = cat.name;// assume category table has field "name", to be enhance later (might have a wizard to let customer choose in case this field does not exist)
            cat.doUpdate();

            rc = cat.getNext();
        }
        printIt("Updated records of category table \"" + obj["category.file.name"] + "\" to set workflow.");
    }

    printIt("Finish migrating request categories.", true);
}

/**
 *
 *  This function to add extra fields into dbdict
 *
 *  @param 	{String} 	dbdictName 	        - dbdict name
 *  @param 	{Array} 	fieldObjects 	    - field object list
 *
 */
function addFieldsToDbdict(dbdictName, fieldObjects) {
        var dbdict = new SCFile("dbdict")
        var sql = "name=\"" + dbdictName + "\"";
        if (dbdict.doSelect(sql) == RC_SUCCESS) {
            var appended = false;
            for(var i=0, len=fieldObjects.length; i&lt;len; i++) {
                if(appendFieldToDbdict(dbdict, fieldObjects[i])==true) {
                    appended = true;
                }
            }
            if(appended==false) {
                return;
            }

        	

            var names = ["record", "boolean1"];
            var values = [dbdict, true];
           	callrad("dbdict.sql.changes", names, values);

            if (dbdict.doUpdate() == RC_SUCCESS) {
                printIt("dbdict \"" + dbdictName + "\"updated.");
                return 0;
            }
        } else {
            printIt("Can not find dbdict \"" + dbdictName + "\"");
        }
}

function appendFieldToDbdict(dbdict, fieldObject) {
    if(checkFieldExistInDbdict(dbdict, null, fieldObject.name)) {
        printIt("The field \"" + fieldObject.name + "\" already exists in dbdict \"" + dbdict.name + "\", ignore it.");
        return false;
    }

    var pos = dbdict.field.length();
    var latestIndex = getLatestIndex("", dbdict);

    dbdict.field[pos].name = fieldObject.name;
    dbdict.field[pos].level = fieldObject.level;
    dbdict.field[pos].index = latestIndex+1;
    dbdict.field[pos].type = fieldObject.type;
    if (fieldObject.len) {
        dbdict.field[pos].sql_field_options['sql.data.type'] = "VARCHAR(" + fieldObject.len + ")";
    }
    return true;
}

/**
 *
 *  This function to get latest index  on dbdict (copied from CITypeService and with minor changes).
 *
 *  @date 1/22/2014
 *  @author Neil Yu
 *
 *  @param 	{String} 	fieldName 	        - field name
 *  @param 	{Object} 	dbdict 	       		- dbdict object
 *  @returns {String} 	index	    	    - return latest index
 *                       -1                 - error when get index
 *
 */
function getLatestIndex(fieldName, dbdict) {
        if ("" == fieldName) {
            var lng = dbdict.field.length();
            var index = 0;
            for (var i = 0; i &lt; lng; i++) {
                if (1 == dbdict.field[i].level &amp;&amp; dbdict.field[i].index&gt;index) {
                    
                    index = dbdict.field[i].index;
                }
            }
            return index;
        } else {
            printIt("Do not support get the index from a structure, TODO, ...");
        }

}

function checkFieldExistInDbdict(dbdict, parentFields, fieldName) {
    if (null == parentFields || parentFields.length==0) {
        var lng = dbdict.field.length();
        for (var i = 0; i &lt; lng; i++) {
            if (1 == dbdict.field[i].level &amp;&amp; dbdict.field[i].name===fieldName) {
                return true;
            }
        }
        return false;
    } else {
        printIt("Do not support check field existence in a structure, TODO, ...");
        return false
    }
}

function migrationMandaten(mandantenMap) {
    printIt("Start migrating mandanten...", true);
    for(fileName in mandantenMap) {
        var newFiles = mandantenMap[fileName];
        printIt("Migrating mandanten field for table \"" + fileName + "\"...");
        var mandantFile = $("scmandant", SCFILE_READONLY).select("filename=\"" + fileName + "\"").uniqueResult();
        if(mandantFile==null) {
            printIt("Can not find mandant for file \"" + fileName + "\", ignore it.");
            continue;
        }

        for(var i=0, len=newFiles.length; i&lt;len; i++) {
            var checkExistFile = $("scmandant", SCFILE_READONLY).select("filename=\"" + newFiles[i] + "\"").uniqueResult();
            if(checkExistFile!=null) {
                printIt("The mandanten field for new file \"" + newFiles[i] + "\" already exists, ignore it.");
                continue;
            }
            var newFile = new SCFile("scmandant");
            newFile.filename = newFiles[i];
            newFile["fieldname"] = mandantFile["fieldname"];
            newFile["linkage.field"] = mandantFile["linkage.field"];
            newFile["source.filename"] = mandantFile["source.filename"];
            newFile["source.fieldname"] = mandantFile["source.fieldname"];
            newFile["excludename"] = mandantFile["excludename"];
            newFile.doInsert();
            addMigrationPatchRecord("scmandant", newFile, newFile["filename"], false);
            printIt("The mandanten field for new file \"" + newFiles[i] + "\" is added.");
        }
        printIt("Migrated mandanten field for table \"" + fileName + "\".");
        
        printIt("Migrating mandanten query for table \"" + fileName + "\"...");
        var scaccess = new SCFile("scaccess", SCFILE_READONLY);
        var rc = scaccess.doSelect('filename="' + fileName + '"');
        while(rc == RC_SUCCESS) {
            for(var i=0, len=newFiles.length; i&lt;len; i++) {
                var checkExistFile = $("scaccess", SCFILE_READONLY).select("filename=\"" + newFiles[i] + "\" and security.id=\"" + scaccess["security.id"] + "\"").uniqueResult();
                if(checkExistFile!=null) {
                    printIt("The mandanten query for new file \"" + newFiles[i] + "\" with security group \"" + scaccess["security.id"] + "\" already exists, ignore it.");
                    continue;
                }
                var newFile = new SCFile("scaccess");
                newFile.filename = newFiles[i];
                newFile["security.id"] = scaccess["security.id"];
                newFile["restricting.query"] = scaccess["restricting.query"];
                newFile.doInsert();
                addMigrationPatchRecord("scaccess", newFile, newFile["filename"], false);
                printIt("The mandanten query for new file \"" + newFiles[i] + "\" with security group \"" + scaccess["security.id"] + "\" is added.");
            }
            

            rc = scaccess.getNext();
        }

        printIt("Migrated mandanten query for table \"" + fileName + "\".");
    }
    printIt("Finished migrating mandanten.", true);
}

function renameOOBCategoryIfConflict() {
    //1. retrieve all legacy category records
    var legacyCategies = [];
    var category = new SCFile("category");
    var rc = category.doSelect('true');
    while(rc == RC_SUCCESS) {
        legacyCategies.push(category.name);
        rc = category.getNext();
    }
    printIt("The legacy categories:" + legacyCategies);

    //2. check PD incident categories
    printIt("Checking conflict imCategories...");
    renameConflictCategories("imCategory", "imSubcategory", "imArea", legacyCategies);

    //3. check PD service desk categories
    printIt("Checking conflict sdCategories...");
    renameConflictCategories("sdCategory", "sdSubcategory", "sdArea", legacyCategies);

    //3. check PD problem categories
    printIt("Checking conflict pbmCategories...");
    renameConflictCategories("pbmCategory", "pbmSubcategory", "pbmArea", legacyCategies);
}

function renameConflictCategories(catFileName, subCatFileName, areaFileName, legacyCategies) {
    var category = new SCFile(catFileName);
    var rc = category.doSelect('true');
    while(rc == RC_SUCCESS) {
        printIt("Checking " + catFileName + " \"" + category["name"] + "\"");
        if(!_.endsWith(category["name"], PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX) &amp;&amp; containsInArray(legacyCategies, category["name"])) {
            if($(catFileName, SCFILE_READONLY).select("name=\"" + category["name"] + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\"").uniqueResult()==null) {
                printIt("Updating " + catFileName + " \"" + category["name"] + "\" to name \"" + category["name"] + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\"...");
                var oldCategoryName = category["name"];
                // rename the category name if conflict
                category["name"] = category["name"] + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX;
                category.doUpdate();
                addMigrationPatchRecord(catFileName, category, category["name"], false);
                printIt("Updated " + catFileName + " \"" + category["name"] + "\" to name \"" + category["name"] + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\".");

                // the subcategies and area should be updated by trigger while updating the category, below code just in case trigger is disabled
                // rename the related subcategory's category name
                var subcategory = new SCFile(subCatFileName);
			    var rcSubcategory = subcategory.doSelect('category="' + oldCategoryName + '"');
			    while(rcSubcategory == RC_SUCCESS) {
                    printIt("Updating " + subCatFileName + " \"" + subcategory.subcategory_name + "\"'s category name to \"" + oldCategoryName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\"...");
			        subcategory.category = oldCategoryName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX;
			        subcategory.doUpdate();
                    addMigrationPatchRecord(subCatFileName, subcategory, subcategory.subcategory_name, false);
			        printIt("Updated " + subCatFileName + " \"" + subcategory.subcategory_name + "\"'s category name to \"" + oldCategoryName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\".");

			        rcSubcategory = subcategory.getNext();
			    }
                // rename the related area's category name
                var area = new SCFile(areaFileName);
			    var rcArea = area.doSelect('category="' + oldCategoryName + '"');
			    while(rcArea == RC_SUCCESS) {
                    printIt("Updating " + areaFileName + " \"" + area.area_name + "\"'s category name to \"" + oldCategoryName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\"...");
			        area.category = oldCategoryName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX;
			        area.doUpdate();
                    addMigrationPatchRecord(areaFileName, area, area.area_name, false);
			        printIt("Updated " + areaFileName + " \"" + area.area_name + "\"'s category name to \"" + oldCategoryName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\".");

			        rcArea = area.getNext();
			    }
            }
        }

        rc = category.getNext();
    }
}

function containsInArray(a, obj) {
    var i = a.length;
    while (i--) {
       if (a[i] === obj) {
           return true;
       }
    }

    return false;
}

function checkRecordExist(fileName, query) {
    var file = new SCFile(fileName, SCFILE_READONLY);
    var rc = file.doSelect(query);
    if(rc == RC_SUCCESS) {
        return true;
    }

    return false;
}

function deleteRecords(fileName, query) {
    printIt("Purging records in table \"" + fileName + "\"...");
    var file = new SCFile(fileName);
    /*
    var rc = file.doSelect(query);
    while(rc == RC_SUCCESS) {
        file.doDelete();
        rc = file.getNext();
    }
    */
    file.doPurge(query);
    printIt("Purged records in table \"" + fileName + "\".");

    return;
}

function migrateSearchConfigs() {
    printIt("Start migrating SearchConfigs...", true);
    for(var i=0, len=OBJECT_NAMES.length; i&lt;len; i++) {
        printIt("Start migrating SearchConfig \"" + OBJECT_NAMES[i] + "\"...");
        var searchConfig = $("SearchConfig").select("tablename=\"" + OBJECT_NAMES[i] + "\"").uniqueResult();
        if(searchConfig==null) {
            printIt("Can not find the search configure for \"" + OBJECT_NAMES[i] + "\", ignore it!");
            continue;
        }
        var disabledSearchConfig = $("SearchConfig", SCFILE_READONLY).select("tablename=\"" + OBJECT_NAMES[i] + PD_ENABLEMENT_DISABLE_SUFFIX + "\"").uniqueResult();
        if(disabledSearchConfig!=null) {
            printIt("Found the customer's search configure which is disabled by PD enablement!");
            searchConfig.searchFormat = disabledSearchConfig.searchFormat;
        } else {
            printIt("Can not find the customer's search configure, use default!");
            if("probsummary"===OBJECT_NAMES[i]) {
                searchConfig.searchFormat = "advFind.incident.search";
            } else if("rootcause"===OBJECT_NAMES[i]) {
                searchConfig.searchFormat = "advFind.search.problem";
            } else if("rootcausetask"===OBJECT_NAMES[i]) {
                searchConfig.searchFormat = "advFind.search.problem.task";
            } else if("incidents"===OBJECT_NAMES[i]) {
                searchConfig.searchFormat = "advFind.SD.search";
            } else {
                printIt("No default value for SearchConfig \"" + OBJECT_NAMES[i] + "\", ignore it!");
                continue;
            }
            searchConfig.doUpdate();
            addMigrationPatchRecord("SearchConfig", searchConfig, searchConfig["tablename"], false);
        }
        printIt("Finish migrating SearchConfig \"" + OBJECT_NAMES[i] + "\".");
    }
    printIt("Finish migrating SearchConfigs.", true);
}

/**
 * Restore the legacy request menu
 */
function restoreLegacyRequestMenu() {
    printIt("Starting retoring legacy request menus...", true);
    // the menus which need to be add legacy request menu back, TODO, currently only HOME menu is here
    var menus = ["HOME"];
    for(var i=0, len=menus.length; i&lt;len; i++) {
        printIt("Retoring legacy request menu in menu \"" + menus[i] + "\"...");
        var menu = $("menu").select("name=\"" + menus[i] + "\"").uniqueResult();
        if(menu==null) {
            printIt("Can not find menu \"" + menus[i] + "\", ignore it.");
            continue;
        }
        if(checkMenuItemExist(menu, "menu.manager", "name", "RM")) {
            printIt("The menu item for legacy request is already in menu \"" + menus[i] + "\", ignore it.");
            continue;
        }

        var nextOption = getNextMenuItemOption(menu);
        var idx = menu.application.length();
        menu.option[idx] = nextOption;
        menu.icon[idx] = "icon-request-mgnt";
        menu.description[idx] = "Request Management";
        menu.application[idx] = "menu.manager";
        menu.pname[idx] = "name";
        menu.pvalue[idx] = "RM";
        menu.condition[idx] = system.functions.parse('lioption("Request Management") and ( nullsub(jscall("security.getRights", "Quote", "view"),"false")="true" or nullsub(jscall("security.getRights", "Order", "view"),"false")="true" or nullsub(jscall("security.getRights", "Line Item", "view"),"false")="true" or nullsub(jscall("security.getRights", "Legacy Request Management Configuration", "view"),"false")="true")', 2);
        menu.doUpdate();
        addMigrationPatchRecord("menu", menu, menu["name"], false);
        printIt("Retored legacy request menu in menu \"" + menus[i] + "\".");
    }
    printIt("Finish retoring legacy request menus.", true);
}

/**
 * @param {menu}
 *            menu - the menu record.
 * @param {String}
 *            itemApplication - The menu item application name
 * @param {String}
 *            itemParamName - The menu item parameter name
 * @param {String}
 *            itemParamValue - The menu item parameter value
 */
function checkMenuItemExist(menu, itemApplication, itemParamName, itemParamValue) {
    if(null==menu) {
        return false;
    }

    var applications = menu.application;
    if(null==applications) {
        return false;
    }
    
    var pnames = menu.pname;
    var pvalues = menu.pvalue;

    for(var i=0, len=applications.length(); i&lt;len; i++) {
        if(itemApplication===applications[i] &amp;&amp; itemParamName===pnames[i] &amp;&amp; itemParamValue===pvalues[i]) {
            return true;
        }
    }

    return false;
}


/**
 * @param {menu}
 *            menu - the menu record.
 */
function getNextMenuItemOption(menu) {
    if(null==menu) {
        return 1;
    }

    var currentOptions = menu.option;
    if(null==currentOptions) {
        return 1;
    }

    var retOption = 0;
    for(var i=0, len=currentOptions.length(); i&lt;len; i++) {
        if(retOption &lt; currentOptions[i]) {
            retOption = currentOptions[i];
        }
    }

    return retOption+1;
}

//TODO
function migrateRequestSecurity() {
    printIt("Start enabling Security for Request Module...", true);

    //1. create secModule
    var secModule = $("secModule", SCFILE_READONLY).select("name=\"Legacy Request Management\"").uniqueResult();
    if(null!=secModule) {
        printIt("The Security Module \"Legacy Request Management\" has already been created, ignore!");
    } else {
        pdSecModule = $("secModule", SCFILE_READONLY).select("name=\"Request Management\"").uniqueResult();
        secModule = new SCFile("secModule");
        secModule.name = "Legacy Request Management";
        if(null!=pdSecModule) {
            secModule.licenseToken = pdSecModule.licenseToken;
        } else {
            secModule.licenseToken = "Request Management";
        }
        secModule.doInsert();
        printIt("Created Security Module \" + secModule.name + \"!");
    }
    //2. create secArea
    //2.0 the legacy secArea for configuration
    var areaName = "Legacy Request Management Configuration";
    var secArea = $("secArea", SCFILE_READONLY).select("module=\"Legacy Request Management\" and name=\"" + areaName + "\"").uniqueResult();
    if(null!=secArea) {
        printIt("The Security Area \"" + areaName + "\" of module \"Legacy Request Management\" has already been created, ignore!");
    } else {
        secArea = new SCFile("secArea");
        secArea.name = areaName;
        secArea.module = "Legacy Request Management";
        secArea.doInsert();
        printIt("Created Security Area \"" + areaName + "\" of module \"Legacy Request Management\".");
    }
    //2.1 the area for accessing transition data
    for(var i=0, len=REQUEST_OBJECT_NAMES.length; i&lt;len; i++) {
        // 2.1.1 secArea itself
        var areaName = getAreaName(REQUEST_OBJECT_NAMES[i]);
        var secArea = $("secArea", SCFILE_READONLY).select("module=\"Legacy Request Management\" and name=\"" + areaName + "\"").uniqueResult();
	    if(null!=secArea) {
	        printIt("The Security Area \"" + areaName + "\" of module \"Legacy Request Management\" has already been created, ignore!");
	    } else {
	        secArea = new SCFile("secArea");
	        secArea.name = areaName;
	        secArea.module = "Legacy Request Management";
	        secArea.doInsert();
	        printIt("Created Security Area \"" + areaName + "\" of module \"Legacy Request Management\".");
	    }
    }

    //3. migrate profile
    var ret=0;
    upgradeRequestProfiles();
/*
    system.functions.rtecall("trigger", ret, 0);
    lib.processDesignerChangeUpgrade.upgradeOperators();
    system.functions.rtecall("trigger", ret, 1);  
    lib.processDesignerChangeUpgrade.upgradeUserRoles();
*/
    printIt("Finish enabling Security for Request Module", true);
}

function upgradeRequestProfiles() {
    var profileFileName = "ocmprofile";
    var upgradeInfoObj = {};
	// all the fields not included in this oob dbdict list will treat as custmoized fields
	upgradeInfoObj["dbdict_profile_930"] = ["access.li","active.query","alert.add","alert.brw","alert.del","alert.upd","all","all.query","allowed.cats","allowedStatus","append.query","appr.active","apprcfrm.delete","apprdis","apprdism","approval.groups","approvals","approve","approve.add","approve.brw","approve.del","approve.delegate","approve.mass","approve.override","approve.reeval","approve.reset","approve.upd","apprun","area","audit","avail.to.order","bg.fkey","calcrsk","cat","cfrm.alertdel","cfrm.close","cfrm.copy","cfrm.end","cfrm.nextphase","cfrm.open","cfrm.phasechg","cfrm.printIt","cfrm.reopen","cfrm.update","clear","close","closed.update","count","cpyopn","database","default.category","deferred","duplicates","expand","fill","find","generate.order","groups","history","initial.fmt","line.initial.inbox","line.manage.format","manager.group","mod.time.limit","mult.select","name","name.alias","new","new.category","new.phase","open","order.initial.inbox","order.manage.format","pagelist","partial.key","phase.log","post","printIt","printIt.bg","printIt.fg","printIt.qbe","printer","qbe.format","qbelist.format","qbelist.report","qberecs","qberecs.format","qberecs.report","qberestore","query.time.limit","query.window","quote.initial.inbox","quote.manage.format","receive","reopen","require.password","scripts","search.format","select.components","skip.warning","split","standard","statements","structured","subtotal","sysmodcount","sysmodtime","sysmoduser","update","valid.lkup","view","views"];
	// TODO, to add more fields in legacy profile "ocmprofile"
	upgradeInfoObj["mapped_fields"] = REQUEST_PROFILE_MAPPED_FIELDS;
	upgradeInfoObj["profile_dbdict_name"] = profileFileName;
	upgradeInfoObj["script_setup_name"] = "SecuritySetupEnvironment";
	upgradeInfoObj["areas"] = ["Quote","Order", "Line Item"];

    //1. add default mapped fields into setting configuration of the secArea
    insertFieldsToSettingsConfig(getFields(upgradeInfoObj["mapped_fields"], profileFileName), upgradeInfoObj, false);

    //2. append customer tailored fields into setting configuration of the secArea
    var list = lib.SecurityProfileCopy.getTailoredFields(upgradeInfoObj);
    printIt("The field list to be added into setting of the Quote/Order/Line Line secAreas:" + list);
    insertFieldsToSettingsConfig(list, upgradeInfoObj, true);

    var mappedFields = upgradeInfoObj["mapped_fields"];

    var profile = new SCFile(upgradeInfoObj["profile_dbdict_name"]);
    var sql = "true";

    if (profile.doSelect(sql) == RC_SUCCESS) {
        do {
            var role = new SCFile("secRole");
            var roleName = profile.name + MIGRATE_PROFILE_SUFFIX;
            var sql = "name=\"" + roleName + "\"";
            if (role.doSelect(sql) != RC_SUCCESS) {
                role.name = roleName;
                role.description = profile.name;
                role.doInsert();
                printIt("Create security role \"" + roleName + "\".");
            } else {
                printIt("The security role \"" + roleName + "\" already exists, ignore the creationg.");
            }

            var delete_right="never";
          	var admin_right=false;
          	var expert_right=false;
          	if (profile.close == true) {
          	    delete_right = "always";
          	}
          	if (profile.audit==true || profile.pagelist==true || profile.valid_lkup==true || profile.alert_brw==true || profile.approve_mass==true || profile.apprdism==true) {
          	    expert_right = true;
          	}
			if (profile.approve_override==true) {
			    admin_right = true;
			}
			var rightObj={"new":profile._new,"view":profile.view,"update":profile.update,"delete":delete_right,"admin":admin_right,"expert":expert_right};
         	if(profile.area=="q") {
         	    lib.SecurityProfileCopy.updateRights(roleName, profile,"Quote",rightObj,"ocmq",{"assign.groups":"assignmentGroup"});
         	} else if(profile.area=="o") {
         	    lib.SecurityProfileCopy.updateRights(roleName, profile,"Order",rightObj,"ocmo",{"assign.groups":"assignmentGroup"});
         	} else if(profile.area=="l") {
         	    lib.SecurityProfileCopy.updateRights(roleName, profile,"Line Item",rightObj,"ocml",{"assign.groups":"assignmentGroup"});
         	} else {
         	    lib.SecurityProfileCopy.updateRights(roleName, profile,"Quote",rightObj,"ocmq",{"assign.groups":"assignmentGroup"});
         	    lib.SecurityProfileCopy.updateRights(roleName, profile,"Order",rightObj,"ocmo",{"assign.groups":"assignmentGroup"});
         	    lib.SecurityProfileCopy.updateRights(roleName, profile,"Line Item",rightObj,"ocml",{"assign.groups":"assignmentGroup"});
            }
        } while (profile.getNext() == RC_SUCCESS);
    }
/**/
}

/**
 * return a list of Object which contains the field name and type
 */
function getFields(fieldNames, fileName) {
  var list = new Array();
  var profileDbdict = new SCFile("dbdict");
  profileDbdict.doSelect("name=\""+fileName+"\"");
  var allFields = profileDbdict.field;
  //  support number (1 number), string (2 character),  boolean (4 logical), record (6 record), list (8 array), condition( 11 expression)
  var allowedType = [1, 2, 4, 8, 11, 6]; //6,
  for (var i = 0; i &lt; allFields.length(); i++) {
    if (allFields[i] != null &amp;&amp; allFields[i].level == 1 &amp;&amp; lib.ArrayUtil.contains(allowedType, allFields[i].type)) {
      //avoid field alias
      if(i&gt;0 &amp;&amp; allFields[i].level == allFields[i-1].level &amp;&amp; allFields[i].index == allFields[i-1].index){
        continue;
      }
      var name = allFields[i].name;
      if(lib.ArrayUtil.contains(fieldNames, name)) {

        list.push([name, allFields[i].type]);
        continue;
      }
    }
  }

  return list;
}


function insertFieldsToSettingsConfig(list, upgradeInfoObj, updateSL) {
  var areas = upgradeInfoObj["areas"];
  var scriptLibrary = new SCFile("ScriptLibrary");
  scriptLibrary.doSelect("name=\"" + upgradeInfoObj["script_setup_name"] + "\"");
  var script = scriptLibrary.script;
  var lines = script.split("\n");
  var initialLines = lines.length;
  for(var type=0;type&lt;areas.length; type++ ){
      var area = areas[type];
      var table = areaTableMap[area];
      for (var i = 0; i &lt; list.length; i++) {
            var scFile = new SCFile("settingsConfig");
            var item = list[i];
            if(updateSL) {
	            var addingLine = "vars.$G_"+table+"_environment[\"" + item[0] + "\"] =system.functions.val(lib.security.getToken(\""+area+"\", \"" + item[0] + "\")," + item[1] + ");";
	            var insertPoint = lib.ArrayUtil.indexOf(lines, "/**end "+table+" tailoring fields**/");
	            //always add to the last line
	            if (insertPoint &gt; 0 &amp;&amp; !lib.ArrayUtil.contains(lines, addingLine)) {
	                  lines.splice(insertPoint, 0, addingLine);
	            }
	        }

            if (scFile.doSelect("setting=\"" + area + "\" and id=\"" + item[0] + "\"") != RC_SUCCESS) {
                  scFile.setting = area;
                  scFile.settingType = "area";
                  scFile.id = item[0];
                  scFile.label = lib.SecurityProfileCopy.setFieldLable(item[0]);
                  switch ("" + item[1]) {
                  case "4":
                        scFile.type = "boolean";
                        break;
                  case "6":
                        scFile.type = "record";
                        break;
                  case "8":
                        scFile.type = "list";
                        break;
                  default:
                        scFile.type = "string";
                        break;
                  }
                  scFile.doSave();
                  printIt("Inserted new fields:\"" + item + "\" into settingsConfig area:" + area);
            } else {
                printIt("The fields:\"" + item + "\" already exists in settingsConfig area:" + area + ", ignore.");
            }
      }
  }

  if(updateSL &amp;&amp; initialLines&lt;lines.length){
        scriptLibrary.script = lines.join("\n");
        scriptLibrary.doSave();
        printIt("Inserted into ScriptLibrary \"" + upgradeInfoObj["script_setup_name"] + "\" for added fields");
  }
}

function getAreaName(objName) {
    var obj = $("Object", SCFILE_READONLY).select("file.name=\"" + objName + "\"").uniqueResult();
    if(null==obj) {
        return objName;
    }

    var localName = null;
    var scmsg = $("scmessage").select("syslanguage=\"en\" and class=\"tablename\" and message.id=\"" + obj["file.name"] + "\"").uniqueResult();
    if(null == scmsg) {
        printIt("Can not found the english table name of object \"" + obj["file.name"] + "\", use object name directly!");
        localName = obj["file.name"];
    } else {
        localName = scmsg.message;
    }

    return localName;
}

/**
 * Merge the link lines from newest OOB to customized one, which will
 *   . handle the category/subcategory/product.type link lines specifically to refer to PD category related tables
 *   . merge the new link lines in newest OOB link to customized link.
 * 
 * @param {array of String}
 *            fileNames - The HelpDesk file names.
 * 
 * @return
 */
function mergeMasterLinkLines(fileNames) {
    var retChangedLinks = [];
    if(fileNames==null) {
        return;
    }
    for(var i=0, len=fileNames.length; i&lt;len; i++) {
        var fileName = fileNames[i];
        if(fileName==null || fileName=="") { // ignore the empty link name
            continue;
        }

        // to link is the customized link
        var toLink = $("link").select("name=\"" + fileName + "\"").uniqueResult();
        if(null==toLink) {
            printIt("The link \"" + fileName + "\" can not be found, ignore the merge from OOB to customized Link!");
            continue;
        }
        // from link is the newest OOB link which is renamed by upgrade tool if the link is customized
        var fromLink = $("link", SCFILE_READONLY).select("name=\"" + UPGRADE_PREFIX + fileName + "\"").uniqueResult();
        if(null==fromLink) {
            printIt("The link \"" + fileName + "\" is not customized, ignore the merge from OOB to customized Link!");
            continue;
        }

        // backup the orginal link
        var linkBak = $("link").select("name=\"" + fileName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
        if(null != linkBak) {// the backup link already exists, ignore the backup
	        printIt("The backup of the link " + fileName + " exists already, ignore the backup.");
    	} else {// backup the link
	        var linkBak = $("link").select("name=\"" + fileName + "\"").uniqueResult();
	        linkBak.name = fileName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
	        linkBak.doInsert();
	        printIt("The link " + fileName + " is backuped to " + fileName + PD_CODE_MIGRATION_DISABLE_SUFFIX);
	    }

        // special handle for category related link lines
        toLink = $("link").select("name=\"" + fileName + "\"").uniqueResult();
        var toLinkChangedFlag1 = handleCategoryRelatedLinkLines(fromLink, toLink);

        // get new link lines in OOB newest link, and merge to customized link
        toLink = $("link").select("name=\"" + fileName + "\"").uniqueResult();
        var diffFieldArray = getDiffItems(fromLink["source.fields"], toLink["source.fields"]);
        
        if(toLinkChangedFlag1 || (diffFieldArray!==null &amp;&amp; diffFieldArray.length&gt;0)) {// backup the orginal link
            var linkBak = $("link").select("name=\"" + fileName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
            if(null != linkBak) {// the backup link already exists, ignore the backup
		        printIt("The backup of the link " + fileName + " exists already, ignore the backup.");
	    	} else {// backup the link
		        var linkBak = $("link").select("name=\"" + fileName + "\"").uniqueResult();
		        linkBak.name = fileName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
		        linkBak.doInsert();
		        printIt("The link " + fileName + " is backuped to " + fileName + PD_CODE_MIGRATION_DISABLE_SUFFIX);
		    }
        }

        if(diffFieldArray!==null &amp;&amp; diffFieldArray.length&gt;0) {
            toLink = $("link").select("name=\"" + fileName + "\"").uniqueResult();
            utilMigrateLinkLineByLink(fromLink, toLink, diffFieldArray);
        }
        if(toLinkChangedFlag1 || (diffFieldArray!==null &amp;&amp; diffFieldArray.length&gt;0)) {
            retChangedLinks.push(fileName);
        }
    }

    return retChangedLinks;
}

/**
 *
 * @return boolean true if the toLink is changed
 */
function handleCategoryRelatedLinkLines(fromLink, toLink) {
    var retFlag = false;
    for(var i=0, len=fromLink["source.fields"].length(); i&lt;len; i++) {
        if(fromLink["source.fields"][i]==="category" &amp;&amp; fromLink["target.files"][i]==="category") {
            fromLink["source.fields"][i] = fromLink["source.fields"][i] + PD_CODE_MIGRATION_DISABLE_SUFFIX;
        } else if(fromLink["source.fields"][i]==="category" + PD_ENABLEMENT_TOBE_USED_SUFFIX &amp;&amp; fromLink["target.files"][i]!=="category") {
            fromLink["source.fields"][i] = "category";
        } else if(fromLink["source.fields"][i]==="subcategory" &amp;&amp; fromLink["target.files"][i]==="subcategory") {
            fromLink["source.fields"][i] = fromLink["source.fields"][i] + PD_CODE_MIGRATION_DISABLE_SUFFIX;
        } else if(fromLink["source.fields"][i]==="subcategory" + PD_ENABLEMENT_TOBE_USED_SUFFIX &amp;&amp; fromLink["target.files"][i]!=="subcategory") {
            fromLink["source.fields"][i] = "subcategory";
        } else if(fromLink["source.fields"][i]==="product.type" &amp;&amp; fromLink["target.files"][i]==="producttype") {
            fromLink["source.fields"][i] = fromLink["source.fields"][i] + PD_CODE_MIGRATION_DISABLE_SUFFIX;
        } else if(fromLink["source.fields"][i]==="product.type" + PD_ENABLEMENT_TOBE_USED_SUFFIX &amp;&amp; fromLink["target.files"][i]!=="producttype") {
            fromLink["source.fields"][i] = "product.type";
        }
    }

    for(var i=0, len=toLink["source.fields"].length(); i&lt;len; i++) {
        if(toLink["source.fields"][i]==="category" &amp;&amp; toLink["target.files"][i]==="category") {
            toLink["source.fields"][i] = toLink["source.fields"][i] + PD_CODE_MIGRATION_DISABLE_SUFFIX;
            retFlag = true;
        } else if(toLink["source.fields"][i]==="subcategory" &amp;&amp; toLink["target.files"][i]==="subcategory") {
            toLink["source.fields"][i] = toLink["source.fields"][i] + PD_CODE_MIGRATION_DISABLE_SUFFIX;
            retFlag = true;
        } else if(toLink["source.fields"][i]==="product.type" &amp;&amp; toLink["target.files"][i]==="producttype") {
            toLink["source.fields"][i] = toLink["source.fields"][i] + PD_CODE_MIGRATION_DISABLE_SUFFIX;
            retFlag = true;
        }
    }
    if(retFlag) {
        toLink.doUpdate();
        addMigrationPatchRecord("link", toLink, toLink["name"], false);
    }

    return retFlag;
}

/**
 * This util is help to copy the link line from 1 link to another, ususally it will be used
 * while customer upgrades their system as current upgrade merge tool is not smart enough.
 */
function utilMigrateLinkLineByName(fromLinkName, toLinkName, linkLines) {
    var fromLink = $("link", SCFILE_READONLY).select("name=\"" + fromLinkName + "\"").uniqueResult();
    if(null==fromLink) {
        printIt("The from link can not be found, ignore!");
        return;
    }
    var toLink = $("link").select("name=\"" + toLinkName + "\"").uniqueResult();
    if(null==toLink) {
        printIt("The to link can not be found, ignore!");
        return;
    }
    utilMigrateLinkLineByLink(fromLink, toLink, linkLines);
}

function utilMigrateLinkLineByLink(fromLink, toLink, linkLines) {
    printIt("Start migrating linklines from " + fromLink.name + " to " + toLink.name + "...");
    if(null==linkLines || linkLines.length==0) {
        printIt("You do not specify any diff link lines, ignore!");
        return;
    }
    vars["$L.from.link"] = fromLink;
    vars["$L.to.link"] = toLink;

    var fromLinkLineLen = fromLink["source.fields"].length();
    for(var i=0, len=linkLines.length; i&lt;len; i++) {
        printIt("Migrating linkline " + linkLines[i] + "...");
        var fromIdx = getItemIndexInSMArray(fromLink["source.fields"], linkLines[i]);
        if(-1 == fromIdx) {
            printIt("The link line " + linkLines[i] + " can not be found in from link, ignore!");
            continue;
        }
        var toIdx = getItemIndexInSMArray(toLink["source.fields"], linkLines[i]);
        if(toIdx &gt; -1) {
            printIt("The link line " + linkLines[i] + " already exists in to link, ignore!");
            continue;
        }
        var currentToLinkLineLen = toLink["source.fields"].length();
        /*
        if(currentToLinkLineLen&gt;0
          &amp;&amp; (toLink["source.fields"][currentToLinkLineLen]==null||toLink["source.fields"][currentToLinkLineLen]=="")) {
            currentToLinkLineLen--;
        }
        */

        /*
        toLink["source.fields"][currentToLinkLineLen] = fromLink["source.fields"][fromIdx];
        toLink["target.files"][currentToLinkLineLen] = fromLink["target.files"][fromIdx];
        toLink["target.fields"][currentToLinkLineLen] = fromLink["target.fields"][fromIdx];
        toLink["comment"][currentToLinkLineLen] = fromLink["comment"][fromIdx];
        toLink["add.query"][currentToLinkLineLen] = fromLink["add.query"][fromIdx];// always store string type of this field????
        toLink["qbe.format"][currentToLinkLineLen] = fromLink["qbe.format"][fromIdx];
        toLink["sort.fields"][currentToLinkLineLen] = fromLink["sort.fields"][fromIdx];
        toLink["project.source.fields"][currentToLinkLineLen] = fromLink["project.source.fields"][fromIdx];
        toLink["project.target.fields"][currentToLinkLineLen] = fromLink["project.target.fields"][fromIdx];
        toLink["link.expressions"][currentToLinkLineLen] = fromLink["link.expressions"][fromIdx];
        toLink["post.expressions"][currentToLinkLineLen] = fromLink["post.expressions"][fromIdx];
        toLink["structure"][currentToLinkLineLen] = fromLink["structure"][fromIdx];
        toLink["target.formats"][currentToLinkLineLen] = fromLink["target.formats"][fromIdx];
        toLink["javascript.pre"][currentToLinkLineLen] = fromLink["javascript.pre"][fromIdx];
        toLink["javascript.post"][currentToLinkLineLen] = fromLink["javascript.post"][fromIdx];
        toLink["target.sort.field"][currentToLinkLineLen] = fromLink["target.sort.field"][fromIdx];
        toLink["target.sort.order"][currentToLinkLineLen] = fromLink["target.sort.order"][fromIdx];
        */
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in source.fields in $L.to.link = " + (fromIdx+1) + " in source.fields in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in target.files in $L.to.link = " + (fromIdx+1) + " in target.files in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in target.fields in $L.to.link = " + (fromIdx+1) + " in target.fields in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in comment in $L.to.link = " + (fromIdx+1) + " in comment in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in add.query in $L.to.link = " + (fromIdx+1) + " in add.query in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in qbe.format in $L.to.link = " + (fromIdx+1) + " in qbe.format in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in sort.fields in $L.to.link = " + (fromIdx+1) + " in sort.fields in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in project.source.fields in $L.to.link = " + (fromIdx+1) + " in project.source.fields in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in project.target.fields in $L.to.link = " + (fromIdx+1) + " in project.target.fields in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in link.expressions in $L.to.link = " + (fromIdx+1) + " in link.expressions in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in post.expressions in $L.to.link = " + (fromIdx+1) + " in post.expressions in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in structure in $L.to.link = " + (fromIdx+1) + " in structure in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in target.formats in $L.to.link = " + (fromIdx+1) + " in target.formats in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in javascript.pre in $L.to.link = " + (fromIdx+1) + " in javascript.pre in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in javascript.post in $L.to.link = " + (fromIdx+1) + " in javascript.post in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in target.sort.field in $L.to.link = " + (fromIdx+1) + " in target.sort.field in $L.from.link", 11);
        system.functions.parse_evaluate((currentToLinkLineLen+1) + " in target.sort.order in $L.to.link = " + (fromIdx+1) + " in target.sort.order in $L.from.link", 11);

        printIt("Finish linkline " + linkLines[i] + "...");
    }
    toLink.doUpdate();
    addMigrationPatchRecord("link", toLink, toLink["name"], false);

    printIt("Finish migrating linklines from " + fromLink.name + " to " + toLink.name + ".");
}

function getItemIndexInSMArray (sourceFields, linkLineName) {
    var ret = -1;
    for(var i=0, len=sourceFields.length(); i&lt;len; i++) {
        if(sourceFields[i]==linkLineName) {
            ret = i;
            break;
        }
    }

    return ret;
}

/**
 * Change the validation against non-PD category related tables to PD related tables.
 * 
 * @param {array of String}
 *            fileNames - The HelpDesk file names which need to be handled.
 * 
 * @return
 */
function migrateValidity(pdCategoryMap) {
    // make sure the related field names in pd category table should keep consistent as non-PD
    // such changes are not put into OOB because the changes are only useful for PD wrapper customers.
    // the PD subcategory talbes, need to add alias subcategory.name
    lib.PDCodeMigrationUtil.addFieldAliasName("imSubcategory", "subcategory.name", "subcategory");
    lib.PDCodeMigrationUtil.addFieldAliasName("sdSubcategory", "name", "subcategory");
    lib.PDCodeMigrationUtil.addFieldAliasName("pbmSubcategory", "subcategory.name", "subcategory");
    // the PD area tables, need to add alias on area.name
    lib.PDCodeMigrationUtil.addFieldAliasName("imArea", "area.name", "product.type");
    lib.PDCodeMigrationUtil.addFieldAliasName("sdArea", "area.name", "product.type");
    lib.PDCodeMigrationUtil.addFieldAliasName("pbmArea", "area.name", "product.type");

    var retArray = [];
    var validity = new SCFile("validity");

    var sql = 'query.file="category" or query.file="subcategory"  or query.file="producttype"';
    var rc = validity.doSelect(sql);
    while(rc == RC_SUCCESS) {
        var validityName = "Unique ID:" + validity.filename + ";Field Name:" + validity.field_name + ";Sequence:" + validity.sequence;

        // 0. ignore the backup record
        if(isIgnoreRecord(validity.filename, false) || isIgnoreRecord(validity.field_name, false)) {
            rc = validity.getNext();
            continue;
        }
        // and ignore the records which does not defined in the pdCategoryMap
        var categoryMap = null;
        for(var file in pdCategoryMap) {
            if(getItemIndexInSMArray(validity.files, file) &gt; -1) {
                categoryMap = pdCategoryMap[file];
            }
        }
        if(categoryMap==null) {
            printIt("The validity record " + validityName + " is not in the handled files, ignore it!");
            rc = validity.getNext();
            continue;
        }

        // 1. backup
        var queryStr = buildValidityQuery(validity.filename + PD_CODE_MIGRATION_DISABLE_SUFFIX,
          validity.field_name + PD_CODE_MIGRATION_DISABLE_SUFFIX, validity.sequence);
        var validityBak = $("validity").select(queryStr).uniqueResult();
        if(null != validityBak) {// the backup validity already exists, ignore the backup
	        printIt("The backup of the link " + linkName + " exists already, ignore the backup.");
    	} else {// backup the validity
	        queryStr = buildValidityQuery(validity.filename, validity.field_name, validity.sequence);
	        var validityBak = $("validity").select(queryStr).uniqueResult();
	        validityBak.filename = validity.filename + PD_CODE_MIGRATION_DISABLE_SUFFIX;
	        validityBak.field_name = validity.field_name + PD_CODE_MIGRATION_DISABLE_SUFFIX;
	        validityBak.doInsert();
	        var validityBackupName = "Unique ID:" + validity.filename + PD_CODE_MIGRATION_DISABLE_SUFFIX
	          + ";Field Name:" + validity.field_name + PD_CODE_MIGRATION_DISABLE_SUFFIX + ";Sequence:" + validity.sequence;
	        printIt("The validity " + validityName + " is backuped to " + validityBackupName);
	    }

        // 2. change validity and save
        validity.query_file = categoryMap[validity.query_file];
        validity.doUpdate();
        addMigrationPatchRecord("validity", validity, validityName, true);
        retArray.push(validityName);

		rc = validity.getNext();
	}

    return retArray;
}

function getRTEVersion() {
    var ret = system.functions.version();
    return ret[2].substring(0,4);
}

function buildValidityQuery(uId, fieldName, sequence) {
    var query = "";
    if(uId == null) {
        query += "filename = NULL";
    } else {
        query += "filename=\"" + uId + "\"";
    }
    if(fieldName == null) {
        query += " and field.name = NULL";
    } else {
        query += " and field.name=\"" + fieldName + "\"";
    }
    if(sequence == null) {
        query += " and sequence = NULL";
    } else {
        query += " and sequence=\"" + sequence + "\"";
    }

    return query;
}

/**
 * Disable the category related link linkes in format level links.
 *   . handle the category/subcategory/product.type link lines to disable it.
 * 
 * @param {array of String}
 *            fileNames - The HelpDesk file names which indicate the master link names.
 * 
 * @return
 */
function disableCategoryLinkLinesInFormatLink(fileNames) {
    var retArray = [];
    var link = new SCFile("link");
    var sql = "true";
    var rc = link.doSelect(sql);
    while(rc == RC_SUCCESS) {
	    var linkName = link.name;
	    var isMasterLinkFlag = false;
	    for(var i=0, len=fileNames.length; i&lt;len; i++) {
	        if(linkName === fileNames[i]) { // exaectly the master link
	            isMasterLinkFlag = true;
	            break;
	        }

	        if(_.endsWith(linkName, PD_CODE_MIGRATION_DISABLE_SUFFIX) || _str.startsWith(linkName,"AUDIT")) {
	            isMasterLinkFlag = true;
	            break;
	        }

	        if((_str.startsWith(linkName,"NEW") || _str.startsWith(linkName,"OLD") || _str.startsWith(linkName,"PRE"))
	          &amp;&amp; _.endsWith(linkName, fileNames[i])) { // the renamed master link
			    isMasterLinkFlag = true;
	            break;
			}
	    }
	    if(isMasterLinkFlag===false) {
		    var linkChangedFlag = false;
		    var sourceFields = link["source.fields"];
		    var idx = getItemIndexInSMArray(sourceFields, "category");
		    while(idx!==-1 &amp;&amp; link["target.files"][idx]==="category") {
		        link["source.fields"][idx] = "category" + PD_CODE_MIGRATION_DISABLE_SUFFIX;
		        linkChangedFlag = true;

		        idx = getItemIndexInSMArray(sourceFields, "category");
		    }
		    idx = getItemIndexInSMArray(sourceFields, "subcategory");
		    while(idx!==-1 &amp;&amp; link["target.files"][idx]==="subcategory") {
		        link["source.fields"][idx] = "subcategory" + PD_CODE_MIGRATION_DISABLE_SUFFIX;
		        linkChangedFlag = true;

		        idx = getItemIndexInSMArray(sourceFields, "subcategory");
		    }
		    idx = getItemIndexInSMArray(sourceFields, "product.type");
		    while(idx!==-1 &amp;&amp; link["target.files"][idx]==="producttype") {
		        link["source.fields"][idx] = "product.type" + PD_CODE_MIGRATION_DISABLE_SUFFIX;
		        linkChangedFlag = true;

		        idx = getItemIndexInSMArray(sourceFields, "product.type");
		    }

		    if(linkChangedFlag===true) {
		        var linkBak = $("link").select("name=\"" + linkName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
	            if(null != linkBak) {// the backup link already exists, ignore the backup
			        printIt("The backup of the link " + linkName + " exists already, ignore the backup.");
		    	} else {// backup the link
			        var linkBak = $("link").select("name=\"" + linkName + "\"").uniqueResult();
			        linkBak.name = linkName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
			        linkBak.doInsert();
			        printIt("The link " + linkName + " is backuped to " + linkName + PD_CODE_MIGRATION_DISABLE_SUFFIX);
			    }

		        link.doUpdate();
                addMigrationPatchRecord("link", link, link["name"], false);
		        retArray.push(linkName);
		    }
		}
		rc = link.getNext();
	}

    return retArray;
}

/**
 * This util is help to clean the non-use categories in PD category table.
 */
function utilCleanPDCategories (fileName, catNames) {
    printIt("Start cleaning categories for " + fileName + "...");
    for(var i=0, len=catNames.length; i&lt;len; i++) {
        printIt("Deleting category \"" + catNames[i] + "\"...");
        var category = $(fileName).select("name=\"" + catNames[i] + "\"").uniqueResult();
        if(null==category) {
            printIt("Can not find category \"" + catNames[i] + "\", ignore it");
            continue;
        }
        category.doDelete();

        // purge subcategory and area
        if(fileName=="imCategory") {
          var file = new SCFile("imSubcategory");
          file.doPurge('category="' + catNames[i] + '"');

          file = new SCFile("imArea");
          file.doPurge('category="' + catNames[i] + '"');
        } else if(fileName=="sdCategory") {
          var file = new SCFile("sdSubcategory");
          file.doPurge('category="' + catNames[i] + '"');

          file = new SCFile("sdArea");
          file.doPurge('category="' + catNames[i] + '"');
        }
        printIt("Deleted category \"" + catNames[i] + "\".");
    }
    printIt("Finish cleaning categories for " + fileName + ".");
}

function utilListDbdictFieldNames(dbdictName) {
    var dbdict = lib.upgradeDbdictChangeFieldType.getSchema(dbdictName);
    var fieldListString ="\"";
    for (var i=0, len=dbdict.field.length(); i&lt;len; i++) { 
        if(dbdict.field[i].level==1){
          fieldListString += dbdict.field[i].name;
          if(i==len-1) {
              fieldListString += "\"";
          } else {
              fieldListString += "\", \"";
          }
        }
    }
    print(fieldListString);
}

/**
 * Get the diff items which exists in 1st SM array but does not exist in 2nd SM Array.
 * @return the diff array with JS array type.
 */
function getDiffItems(smArray1, smArray2) {
    var retArray = [];
    if(null==smArray1) {
        return retArray;
    }
    if(null==smArray2) {
        return smArray1.toArray();
    }
    var item;
    for(var i=0, len=smArray1.length(); i&lt;len; i++) {
        item = smArray1[i];
        var flag = false;
        for(var j=0, lenJ=smArray2.length(); j&lt;lenJ; j++) {
            if(item == smArray2[j]) {
                flag = true;
                break;
            }
        }
        if(flag == false) {
            retArray.push(item);
        }
    }

    return retArray;
}

/**
 * Get the diff item positions of smArray1 which exists in 1st SM array but does not exist in 2nd SM Array.
 * @return the position array with JS array type.
 */
function getDiffItemPositions(smArray1, smArray2) {
    var retArray = [];
    if(null==smArray1) {
        return retArray;
    }
    var item;
    for(var i=0, len=smArray1.length(); i&lt;len; i++) {
        item = smArray1[i];
        var flag = false;
        for(var j=0, lenJ=smArray2.length(); j&lt;lenJ; j++) {
            if(item == smArray2[j]) {
                flag = true;
                break;
            }
        }
        if(flag == false) {
            retArray.push(i);
        }
    }

    return retArray;
}

/**
 * Get the positions of smArray1 which item is the same as expected value.
 * @return the position array with JS array type.
 */
function getSameItemPosition(smArray1, value) {
    var retPos = -1;
    if(null==smArray1) {
        return retPos;
    }
    var item;
    for(var i=0, len=smArray1.length(); i&lt;len; i++) {
        if(smArray1[i] == value) {
            retPos = i;
            break;
        }
    }

    return retPos;
}

function mergeArrayFieldValue(toFile, fromFile, fieldName, relatedFieldNames) {
    var customizedNewValuePositions = getDiffItemPositions(fromFile[fieldName], toFile[fieldName]);
    var valueLen = 0;
    if(null!=toFile[fieldName]) {
        valueLen = toFile[fieldName].length();
    }
    // sync related fields from fromFile to toFile if exist
    if(relatedFieldNames!=null) {
        for(var i=0, len=toFile[fieldName].length(); i&lt;len; i++) {
            var sameValuePosition = getSameItemPosition(fromFile[fieldName], toFile[fieldName][i]);
            if(sameValuePosition&lt;0) {// continue if not exist
                continue;
            }
            for(var j=0; j&lt;relatedFieldNames.length; j++) {
                toFile[relatedFieldNames[j]][i] = fromFile[relatedFieldNames[j]][sameValuePosition];
            }
        }
    }
    // append new fields
    for(var i=0, len=customizedNewValuePositions.length; i&lt;len; i++) {
        toFile[fieldName][valueLen] = fromFile[fieldName][customizedNewValuePositions[i]];
        if(relatedFieldNames!=null) {
            for(var j=0; j&lt;relatedFieldNames.length; j++) {
                toFile[relatedFieldNames[j]][valueLen] = fromFile[relatedFieldNames[j]][customizedNewValuePositions[i]];
            }
        }
        valueLen++;
    }

    // remove the items which value of the fieldName is empty in toFile
    removeEmptyItemsFromArray(toFile, fieldName, relatedFieldNames);
}

function removeEmptyItemsFromArray(toFile, fieldName, relatedFieldNames) {
    var fieldValueArray = toFile[fieldName].toArray();
    var relatedFieldsValueObj = {};
    if(relatedFieldNames!=null) {
        for(var i=0; i&lt;relatedFieldNames.length; i++) {
            relatedFieldsValueObj[relatedFieldNames[i]] = toFile[relatedFieldNames[i]].toArray();
        }
    }
    var removedFlag = false;
    if(null!=fieldValueArray) {
	    for(var i=fieldValueArray.length-1; i&gt;=0; i--) {
	        var itemValue = fieldValueArray[i];
	        if(itemValue=="" || itemValue==null) {
	            removedFlag = true;
	            fieldValueArray.splice(i, 1);
	            for(var arrayKey in relatedFieldsValueObj) {
	                if(relatedFieldsValueObj[arrayKey]!=null &amp;&amp; relatedFieldsValueObj[arrayKey].length&gt;i) {
	                    relatedFieldsValueObj[arrayKey].splice(i, 1);
	                }
	            }
	        }
	    }
	}
    if(removedFlag) {
        toFile[fieldName] = fieldValueArray;
        for(var arrayKey in relatedFieldsValueObj) {
            toFile[arrayKey] = relatedFieldsValueObj[arrayKey];
        }
    }
    return removedFlag;
}

/**
 * This method is only invoked if it is upgraded from non-PD,
 * and the PD enablement script should alread by run before run this method.
 */
function migrateChangeModule() {
	var sql = "true";
	var changeCat;
	var taskCat;
    //1. change back categories with suffix "_bak_by_PD" which are the customized records and duplicated with PD OOB category name,
    //   and active it. Meanwhile rename the conflict PD OOB category.
    changeCat = new SCFile("cm3rcategory", SCFILE_READONLY);
	if(changeCat.doSelect(sql) == RC_SUCCESS) {
		do {
		    if(_.endsWith(changeCat["name"], PD_ENABLEMENT_DISABLE_SUFFIX_CHG)) {
			    var oobCatName = changeCat["name"].substring(0, changeCat["name"].indexOf(PD_ENABLEMENT_DISABLE_SUFFIX_CHG));
			    // rename the PD OOB category if exists
			    renameChangeCategoryName("cm3rcategory", oobCatName, oobCatName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX, false);
			    // rename the customized category to OOB name
			    renameChangeCategoryName("cm3rcategory", changeCat["name"], oobCatName, true);
			    
			    // TODO, rename the OOB workflow name? or use new workflow name for auto generated one?
			}
		} while(changeCat.getNext() == RC_SUCCESS)
	}

	taskCat = new SCFile("cm3tcategory", SCFILE_READONLY);
	if(taskCat.doSelect(sql) == RC_SUCCESS) {
		do {
			if(_.endsWith(taskCat["name"], PD_ENABLEMENT_DISABLE_SUFFIX_CHG)) {
			    var oobCatName = taskCat["name"].substring(0, taskCat["name"].indexOf(PD_ENABLEMENT_DISABLE_SUFFIX_CHG));
			    // rename the PD OOB category if exists
			    renameChangeCategoryName("cm3tcategory", oobCatName, oobCatName + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX, false);
			    // rename the customized category to OOB name
			    renameChangeCategoryName("cm3tcategory", taskCat["name"], oobCatName, true);
			}
		} while(taskCat.getNext() == RC_SUCCESS)
	}

    //2. upgrade categories to generate workflow, ignore the inactive, or which name starts with NEW, OLD, ...
    //   similar implementation is lib.processDesignerChangeUpgrade.upgradeCategories()
    changeCat = new SCFile("cm3rcategory");
	if(changeCat.doSelect(sql) == RC_SUCCESS) {
		do {
		    if(changeCat["avail.cond"]==true
		     &amp;&amp; !_str.startsWith(changeCat["name"],"NEW")
		     &amp;&amp; !_str.startsWith(changeCat["name"],"OLD")) {
			    upgradeChangeCategory(changeCat.name, "change");
			}
		} while(changeCat.getNext() == RC_SUCCESS)

		var phase = new SCFile("cm3rcatphase");
		var rc = phase.doSelect("true");
		while(rc == RC_SUCCESS){
			phase.approvals = null;
			phase.doUpdate();
            addMigrationPatchRecord("cm3rcatphase", phase, phase["name"], false);
			rc = phase.getNext();
		}
	}

	taskCat = new SCFile("cm3tcategory");
	if(taskCat.doSelect(sql) == RC_SUCCESS) {
		do {
			if(taskCat["avail.cond"]==true
		     &amp;&amp; !_str.startsWith(taskCat["name"],"NEW")
		     &amp;&amp; !_str.startsWith(taskCat["name"],"OLD")) {
			    upgradeChangeCategory(taskCat.name, "task");
			}
		} while(taskCat.getNext() == RC_SUCCESS)
	}
}

function renameChangeCategoryName(tableName, orgCatName, newCatName, forceActive) {
    var cat = $(tableName).select("name=\"" + orgCatName + "\"").uniqueResult();
	if(null != cat) {
		cat.name = newCatName;
		if(forceActive) {
		    cat["avail.cond"] = true;
		}
		cat.doUpdate();
		if(tableName==="cm3rcategory") {
			// rename the PD OOB subcategory of this category if exists
			var subCat = new SCFile("cm3rsubcat");
			var subCatRC = subCat.doSelect('category="' + orgCatName + '"');
			while(subCatRC == RC_SUCCESS) {
			    subCat.category = newCatName;
			    if(_.endsWith(subCat.subcategory, PD_ENABLEMENT_DISABLE_SUFFIX_CHG)) {
			        subCat.subcategory = subCat.subcategory.substring(0, subCat.subcategory.indexOf(PD_ENABLEMENT_DISABLE_SUFFIX_CHG));
			    }
			    subCat.doSave();// use doSave instead of doUpdate in case the record exists already.
			    subCatRC = subCat.getNext();
			}
		}
	}
}

function upgradeChangeCategory(name, type) {
	if (name == null) {
		return;
	}

	var changeCat;	
	if (type == "change") {
		changeCat = new SCFile("cm3rcategory");
	} else {
		changeCat = new SCFile("cm3tcategory");
	}

	var sql = "name=\"" + name + "\" and (workflow=NULL or workflow=\"\")";
	if ( changeCat.doSelect( sql ) == RC_SUCCESS ) {
		var workflow = createWorkflow( changeCat, type );
		changeCat.workflow = workflow.name;
		changeCat.doUpdate();
        addMigrationPatchRecord("cm3rcategory", changeCat, changeCat["name"], false);
	}
	
}

function createWorkflow(changeCat, type) {
	var workflow = new SCFile("Workflow");
	var filename="cm3r";
	if (type != "change") {
		filename="cm3t";
	}

	var sql = "name=\"" +changeCat.name + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX + "\" and tableName=\"" +filename+ "\"";
	if (workflow.doSelect( sql ) != RC_SUCCESS) {
		workflow.name = changeCat.name + PD_CODE_MIGRATION_CAT_RENAMED_SUFFIX;
		if (type == "change") {
			workflow.tableName = "cm3r";
		} else {
			workflow.tableName = "cm3t";
		}
		workflow.description= changeCat.description + AUTO_UPGRADED_SUFFIX_IN_DESC;
		workflow.type = "standard";
		workflow.defaultPhase = changeCat.phases[0];
		workflow.firstPhase = changeCat.phases[0];

		if (workflow.doInsert() == RC_SUCCESS) {
            addMigrationPatchRecord("Workflow", workflow, workflow["name"], false);
			lib.processDesignerChangeUpgrade.createPhases(changeCat, workflow, type);
		}
	}
	return workflow;
}

/**
 * Migrate Incident Solution Matching, which will reads the user input
 * from var $use.pd.solution.matching.
 * If var $use.pd.solution.matching is NOT set to false, then
 *   - disable the solution in legacy process by changing the Processes which invokes 
 *     RAD "us.incident.matching.wrapper" or "us.problem.matching" by change the RAD condtion to false,
 *     in OOB such processes are: im.first, im.first.exit, im.first.new, im.first.save
 *   - and add the rule set "im.incident.matching" in the generated workflow "Incident_PDCM";
 */
function migrateIncidentSolutionMatching() {
    if(vars["$use.pd.solution.matching"]===false) {
        printIt("You select to use Non-PD solution matching, ignore the migration for using Non-PD Incident solution matching.", true);

        var reportObj = {};
        reportObj.title = "You selected to keep using non Process Designer-based solution matching, so you need to manually migrated the";
          + " solution matching related configuration from non Process Designer-based profile to Process Designer-based Security. Please refer to the migration guide for more detail.";
        reportObj.needManualCheck = true;
        reportObj.files = [];
        SUMMARY_REPORT_OBJS.push(reportObj);

        return;
    }
    printIt("Start migrating to use PD Incident solution matching...", true);

    // seach out the Processes, and disable the non-PD Incident/Problem matching
    var changedFiles = [];
    var radName1 = "us.incident.matching.wrapper";
    var radName2 = "us.problem.matching";
    var radNameSave = "im.save.problem";
    var process = new SCFile("Process");
    var sql = "application=\"" + radName1 + "\" or application=\"" + radName2 + "\"";
    var rc = process.doSelect(sql);
	while (rc == RC_SUCCESS) {
		if(isIgnoreRecord(process.process, false)) {
		    rc = process.getNext();
		    continue;
		}
		printIt("Changing Process " + process.process + " to disable the non-PD Incident Solution Matching");
		// backup it
		var processBak = $("Process").select("process=\"" + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
        if(null != processBak) {// the backup process already exists, ignore the backup
		    printIt("The backup of the Process " + process.process + " exists already, ignore the backup.");
		} else {// backup the process
		    processBak = $("Process").select("process=\"" + process.process + "\"").uniqueResult();
		    processBak.process = process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX;
		    processBak.doInsert();
		    printIt("The Process " + process.process + " is backuped to " + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX);
		}

		// change the RAD condition to false
		var rads = process.rad;
		var radLen = rads.length()
		for(var i=0; i&lt;radLen; i++) {
		    if (rads[i].application===radName1 || rads[i].application===radName2) {
		        if(null!=rads[i]["rad.condition"]) {
		            var strCond = system.functions.str(rads[i]["rad.condition"]);
		            if(!_str.startsWith(strCond,"false")) {
		                rads[i]["rad.condition"] = system.functions.parse("false and (" + strCond + ")", 2);
		            }
		        } else {
		            rads[i]["rad.condition"] = system.functions.parse("false", 2);
		        }
		    }
		    /*
		    else if (rads[i].application===radNameSave) {// use se.view.engine or se.base.method to replace the non-PD RAD for add/update
		        rads[i].application = "se.view.engine";
		        rads[i].names=["file", "description", "name", "index", "text"];
		        rads[i].values=["$L.file", "$L.action", "$L.related.filename", "$L.related.id", "$L.exit"];
		    }
		    */
		    // else if () // disable the RAD invoke us.save.relation??? TODO, ...
		}

		// append call PD Incident Solution matching RAD at the end of the process
		var radNamePDSolution = "incident.matching";
		if(rads[radLen-1]["application"]==radNamePDSolution) {
		    printIt("The PD solution matching RAD \"" + radNamePDSolution + "\" already configured in the Process \"" + process.process + "\", ignore it.");
		} else {
		    rads[radLen]["application"] = radNamePDSolution;
		    var condStr = "$L.continue and not  ($G.bg)";
		    // append the condition in Ruleset im.incident.matching
		    var pdRuleCondStr = getPDSolutionMatchingRuleCondition();
		    
		    if(pdRuleCondStr==null || pdRuleCondStr=="") {// use default if can not find the condition in rule
		        condStr += " and (jscall(\"security.getRights\",\"Incident\",\"use.solution.matching\")=true and  (jscall(\"ServiceDeskSwitch.getSDSwitch\")=true or (nullsub($isLinkedIncident,false)=false and nullsub($isSDEscalatedIncident,false)=false) ) and nullsub( $sdsolvedirectly,false)=false  and nullsub(first.call in $L.file, false)=false)";
    		    condStr += " and (not  ($G.bg) and nullsub($inChangeCat, false)=false)"
		    } else {
		        condStr += " and " + pdRuleCondStr;
		    }
		    
		    rads[radLen]["rad.condition"] = system.functions.parse(condStr, 2);
		    
		    rads[radLen].names=["file", "types", "name"];
		    rads[radLen].values=["$L.file", "$L.exit.matching", "\"Matched Incident\""];
		    if (rads[radLen]["post.rad.expressions"] == null){
				  rads[radLen]["post.rad.expressions"]=[];
			}
		    rads[radLen]["post.rad.expressions"].push(system.functions.parse("if (null(agreement.ids in $L.file) and not  (null(agreement.id in $L.file))) then (1 in agreement.ids in $L.file=agreement.id in $L.file)", 11));
		    rads[radLen]["post.rad.expressions"].push(system.functions.parse("if same($L.exit.matching, \"back\") then ($L.exit=\"bad.val\")", 11));
		}

		process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);
		changedFiles.push(process.process);

		rc = process.getNext();
	}
	// add to report
    var reportObj = {};
    reportObj.title = "The following process records are updated to disable the non Process Designer-based Incident solution matching "
       + " and to use the Process Designer-based solution matching."
      // + " meanwhile the orginal Process records are backuped with suffix \"" + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\":";
       +  "Backups of the original process (identified by the suffix "+PD_CODE_MIGRATION_DISABLE_SUFFIX+") have been created."
    reportObj.files = changedFiles;
    reportObj.needManualCheck = false;
    reportObj.category="Process";
    reportObj.filename="process";
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    /* currently the ruleset on workflow does not work, so let's comment below code for the time being.
	// update the auto generated workflow to add pd incident solution matching ruleset in trigger event "After Successful Add"
	printIt("Adding RuleSet \"im.incident.matching\" to After Successful Add of the Workflow \"" + PD_CODE_MIGRATION_WF_PREFIX + "Incident" + "\"...");
	var workflow = $("Workflow").select("tableName=\"probsummary\" and name=\"" + PD_CODE_MIGRATION_WF_PREFIX + "Incident" + "\"").uniqueResult();
	if(null!=workflow) {
	    var ruleSetName = "im.incident.matching";
	    if(arrayContains(workflow.afterAddRules, "im.incident.matching")) {
	        printIt("The RuleSet \"im.incident.matching\" already exists in After Successful Add of the Workflow \"" + PD_CODE_MIGRATION_WF_PREFIX + "Incident" + "\", ignore it.");
	    } else {
		    var afterAddRulesLen = workflow.afterAddRules.length();
		    if(afterAddRulesLen&gt;0 &amp;&amp; workflow.afterAddRules[afterAddRulesLen-1] == null) {
		        afterAddRulesLen = afterAddRulesLen - 1;
		    }
		    workflow.afterAddRules[afterAddRulesLen] = ruleSetName;
		    var ret = 0;
		    system.functions.rtecall("trigger", ret, 1);
		    workflow.doUpdate();
		    system.functions.rtecall("trigger", ret, 0);
		    printIt("Added RuleSet \"im.incident.matching\" to After Successful Add of the Workflow \"" + PD_CODE_MIGRATION_WF_PREFIX + "Incident" + "\".");
		}
	} else {
	    printIt("Workflow \"" + PD_CODE_MIGRATION_WF_PREFIX +  Incident" + "\" does not exist, ignore it");
	}
	*/

	printIt("Finish migrating to use PD Incident solution matching.", true);
}

/**
 * Migrate Process to make sure the Rule sets of auto-generated workflow work.
 * @param {array of String}
 *            rads - the RAD used in built-in Processes, which need to pass in the names/values parameters.
 */
function migrateBuiltinProcesses(radNames) {
    printIt("Start migrating built-in Processes to pass in the names/values parameters of RAD call...", true);
    if(radNames==null || radNames.length==0) {
        printIt("The radNames is empty, ignore the migration for Built-in Process.");

        return;
    }

    // seach out the Processes
    var changedFiles = [];
    var process = new SCFile("Process");
    var sql = "";
    for(var i=0, len=radNames.length; i&lt;len; i++) {
        if(i&gt;0) {
            sql += " or "
        }
        sql += "application=\"" + radNames[i] + "\""
    }
    // special handle for Process sm.save
    sql += " or process=\"sm.save\""
    // special handle for Process im.close.bg
    sql += " or process=\"im.close.bg\""

    var rc = process.doSelect(sql);
	while (rc == RC_SUCCESS) {
		if(isIgnoreRecord(process.process, false)) {
		    rc = process.getNext();
		    continue;
		}
		printIt("Changing Process " + process.process + " to makes sure the Rule sets of the auto-generated Workflow working");

		// add names/values to the RAD paramters
		var rads = process.rad;
		var radLen = rads.length();
		var modifyFlag = false;
		for(var i=0; i&lt;radLen; i++) {
		    if(containsInArray(radNames, rads[i].application)
		     || (rads[i].application==="se.base.method" &amp;&amp; process.process==="sm.save")) {
		        if(arrayContains(rads[i].names, "names")) {
		            printIt("The Process " + process.process + " had been already updated to parse into the names/values, ignore the migration for this Process.");
		            break;
		        } else {
		        }
		        modifyFlag = true;
		        // backup it
				var processBak = $("Process").select("process=\"" + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
		        if(null != processBak) {// the backup process already exists, ignore the backup
				    printIt("The backup of the Process " + process.process + " exists already, ignore the backup.");
				} else {// backup the process
				    processBak = $("Process").select("process=\"" + process.process + "\"").uniqueResult();
				    processBak.process = process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX;
				    processBak.doInsert();
				    printIt("The Process " + process.process + " is backuped to " + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX);
				}
				
				if (rads[i]["pre.rad.expressions"] == null){
				  rads[i]["pre.rad.expressions"]=[];
				}
				
		        rads[i]["pre.rad.expressions"].push(system.functions.parse("$L.file.names={\"$L.category\", \"$L.workflow\", \"$L.phase\", \"$L.saved\", \"$L.parent\", \"$L.wfPhase\", \"$L.wfPhase.save\", \"$L.orig.format\", \"$L.wfRules\", \"$L.wfMode\", \"$L.wfType\", \"$L.to.phaseId\"}", 11));
		        rads[i]["pre.rad.expressions"].push(system.functions.parse("if (not null($L.object)) then $L.file.names=denull(local.variables in $L.object) + $L.file.names", 11));
		        rads[i]["pre.rad.expressions"].push(system.functions.parse("$L.file.vars={};$L.file.vars=getvariables($L.file.names)", 11));
		        rads[i].names.push("names");
		        rads[i].names.push("values");
		        rads[i].values.push("$L.file.names");
		        rads[i].values.push("$L.file.vars");
		        if(rads[i].application==="se.base.method" &amp;&amp; process.process==="sm.save" &amp;&amp; !arrayContains(rads[i].names, "boolean1")) {
		            rads[i].names.push("boolean1");
		        	rads[i].values.push("$G.bg");
		        }
		        
		        var addExp=system.functions.parse("if ($L.exit~=\"bad.val\" and $L.exit~=\"badval\") then ($L.void=setvariables($L.file.names, $L.file.vars))", 11);
		        if(rads[i]["post.rad.expressions"]==null) {
		            rads[i]["post.rad.expressions"] = [addExp];
		        }
		        else
		        {		   
		        	//insert as the first line
		            rads[i]["post.rad.expressions"] = system.functions.insert(rads[i]["post.rad.expressions"], 1, 1, addExp);		           
		        }
		    } else if (rads[i].application==="se.call.process" &amp;&amp; process.process==="im.close.bg") {
		        if(!(arrayContains(rads[i].names, "name") &amp;&amp; arrayContains(rads[i].values, "\"im.close\""))) {
		            continue;
		        }
		        //if(arrayContains(rads[i]["pre.rad.expressions"], "$L.values={};$L.values=getvariables($L.names)")) {
		        if(arrayContains(rads[i].names, "second.record")) {
		            printIt("The Process " + process.process + " had been already updated to parse into the second.record, ignore the migration for this Process.");
		            break;
		        }
		        modifyFlag = true;
		        // backup it
				var processBak = $("Process").select("process=\"" + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
		        if(null != processBak) {// the backup process already exists, ignore the backup
				    printIt("The backup of the Process " + process.process + " exists already, ignore the backup.");
				} else {// backup the process
				    processBak = $("Process").select("process=\"" + process.process + "\"").uniqueResult();
				    processBak.process = process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX;
				    processBak.doInsert();
				    printIt("The Process " + process.process + " is backuped to " + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX);
				}

                if (rads[i]["pre.rad.expressions"] == null){
				  rads[i]["pre.rad.expressions"]=[];
				}
		        rads[i]["pre.rad.expressions"].push(system.functions.parse('$L.names=$L.names+{"$L.category", "$L.workflow", "$L.phase", "$L.saved", "$L.parent", "$L.wfPhase", "$L.wfPhase.save", "$L.orig.format", "$L.wfRules", "$L.wfMode", "$L.wfType", "$L.to.phaseId"}', 11));
		        rads[i]["pre.rad.expressions"].push(system.functions.parse("$L.values={};$L.values=getvariables($L.names)", 11));
		        rads[i].names.push("second.record");
		        rads[i].values.push("$L.file.save");
		        if(rads[i]["post.rad.expressions"]==null) {
		            rads[i]["post.rad.expressions"] = [];
		        }
		        rads[i]["post.rad.expressions"].push(system.functions.parse("if ($L.exit~=\"bad.val\" and $L.exit~=\"badval\") then ($L.void=setvariables($L.file.names, $L.file.vars))", 11));
		    }
		}

		if(modifyFlag === true) {
			process.doUpdate();
	        addMigrationPatchRecord("Process", process, process["process"], false);
			changedFiles.push(process.process);
		}

		rc = process.getNext();
	}

	// add to report
    var reportObj = {};
    reportObj.title = "The following process records are updated to pass the names/values parameters into while invoking the main logic RAD,"
       + " which makes sure the Rule sets of the auto-generated workflows can work."
       + "Backups of the original process (identified by the suffix "+PD_CODE_MIGRATION_DISABLE_SUFFIX+") have been created."
    reportObj.files = changedFiles;
    reportObj.category="Process";
    reportObj.filename="process";
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    printIt("Finished migrating built-in Processes to pass in the names/values parameters of RAD call.", true);
}

function isIgnoreRecord(recordName, needIgnoreRenamed) {
    if(_.endsWith(recordName, PD_CODE_MIGRATION_DISABLE_SUFFIX) || _str.startsWith(recordName,"AUDIT")) {
        return true;
    }

    if(needIgnoreRenamed) {
	    if((_str.startsWith(recordName,"NEW") || _str.startsWith(recordName,"OLD") || _str.startsWith(recordName,"PRE"))) {
		    return true;
		}
	}

	return false;
}

function getPDSolutionMatchingRuleCondition() {
    var ruleset = $("RuleSet").select("id=\"im.incident.matching\"").uniqueResult();
    if(null==ruleset) {
        printIt("Return null condition as the RuleSet \"im.incident.matching\" is not found.");
        return null;
    }
    
    var rules = ruleset.rule;
    if(null==rules) {
        printIt("Return null as rules in RuleSet \"im.incident.matching\" is empty");
        return null;
    }
    for(var i=0, len=rules.length(); i&lt;len; i++) {
        if(rules[i].type==="callProcess") {
            var processName = null;
            if(rules[i].ruleJSON!=null &amp;&amp; rules[i].ruleJSON!="") {
                processName = lib.RuleWizardHelpers.getProcessName(rules[i].ruleJSON, true);
            } else {
                if(rules[i].ruleXML!=null &amp;&amp; rules[i].ruleXML!="") {
                     processName = lib.RuleWizardHelpers.getProcessName("&lt;xml&gt;" +rules[i].ruleXML + "&lt;/xml&gt;");
                }
            }
            if(processName==="im.incident.matching") {
                var retCondStr = system.functions.str(rules[i].condition);
                var process = $("Process").select("process=\"" + processName + "\"").uniqueResult();
                if(null==process) {
                    printIt("Return null as Process \"" + processName + "\" is not found");
                    return null;
                }
                var rads = process.rad;
                if(null==rads) {
                    printIt("Return null as rads in Process is empty");
                    return null;
                }
                for(var j=0, len=rads.length(); j&lt;len; j++) {
                    if(rads[j].application==="incident.matching") {
                        retCondStr = "(" + retCondStr + ") and (" + system.functions.str(rads[j]["rad.condition"]) + ")";
                        return retCondStr;
                    }
                }
                printIt("Return null as no RAD \"incident.matching\" call is invoked in Process");
                return null;
            }
        }
    }

    printIt("Return null as no Rule calls process \"im.incident.matching\" in the RuleSet");
    return null;
}

function arrayContains(smArray, item) {
    for(var i=0, len=smArray.length(); i&lt;len; i++) {
        var arrayItem = smArray[i];

        if(typeof(item)==="string" &amp;&amp; typeof(arrayItem)!=="string") {
            arrayItem = system.functions.str(arrayItem);
        }
        if(arrayItem == item) {
            return true;
        }
    }

    return false;
}

/**
 * This function will detect the uasage of "tableAccess in $L.env" in Process, DO, DS and formatctl
 */
function checkTableAccessOfEVNUsage() {

    var resultProcess = checkUsageInProcess("tableAccess in $L.env", "if (exists(\"tableAccess\", $L.env))", null, null);
    for(var process in resultProcess) {
        printIt("--&gt; Process:" + process);
        var expressions = resultProcess[process];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

    var resultDS = checkUsageInDisplayScreen("tableAccess in $L.env", "if (exists(\"tableAccess\", $L.env))", null, null);
    for(var ds in resultDS) {
        printIt("--&gt; DisplayScreen:" + ds);
        var expressions = resultDS[ds];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

    var resultDO = checkUsageInDisplayOption("tableAccess in $L.env", "if (exists(\"tableAccess\", $L.env))", null, null);
    for(var ddo in resultDO) {
        printIt("--&gt; DisplayOption:" + ddo);
        var expressions = resultDO[ddo];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

    var resultFC = checkUsageInFormatctrl("tableAccess in $L.env", "if (exists(\"tableAccess\", $L.env))", null, null);
    for(var fc in resultFC) {
        printIt("--&gt; formatctrl:" + fc);
        var expressions = resultFC[fc];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

}

function detectUncompactibleCodes() {
    printIt("Start detecting uncompactible codes...", true);

    // 0. current.phase in saved record usage, no need to detect as it seems it is not impact non-PD and PD CP3 customers
    //checkSavedRecordUsage();

    // 1. merge the linklines of master link
    var fileNames = ["probsummary", "incidents", "rootcause"];
    var changedFiles = mergeMasterLinkLines(fileNames);
    // set to report
    var reportObj = {};
    reportObj.title = "The following link records are updated to add the latest OOB PD linklines "
       + " and the category related target tables are changed to use PD related category tables."
       + " Backups of the original link records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created."
    reportObj.files = changedFiles;
    reportObj.category="Link";
    reportObj.filename="link";
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    // 2. update the Validity to refer to PD category related tables
    var pdCategoryMap = {
        probsummary: {category: "imCategory", subcategory: "imSubcategory", producttype: "imArea"},
        incidents: {category: "sdCategory", subcategory: "sdSubcategory", producttype: "sdArea"},
        rootcause: {category: "pbmCategory", subcategory: "pbmSubcategory", producttype: "pbmArea"}
    };
    changedFiles = migrateValidity(pdCategoryMap);
    // set to report
    reportObj = {};
    reportObj.title = "The following validity records are updated to perform validation against Process Designer-based category tables (such as category, subcategory, and producttype) instead of legacy category tables."
       + " Backups of the original validity records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
    reportObj.files = changedFiles;
    reportObj.needManualCheck = true;
    reportObj.category="Validity";
    reportObj.filename="validity";
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    // 3. update the format level link to disable the category related link lines
    var ignoreMasterLinks = ["probsummary", "incidents", "rootcause", "rootcausetask", "knownerror", "knownerrortask"];
    var ignoreLinks = ["pm.profile", "core", "IM.new.category", "pm.profile.util",
          "probcause.user", "probcause.user.1", "pm.resolve.cat", "problem.type", "product.type",
          "protocore", "sc.knowledge.prompt.core", "screlate.search.problem", "subcategory", "svcCatalog"];
    changedFiles = disableCategoryLinkLinesInFormatLink(ignoreMasterLinks.concat(ignoreLinks));
    // set to report
    reportObj = {};
    reportObj.title = "The following format level link records are updated to disable the"
       + " category/subcategory/product.type link lines."
       + " Backups of the original link records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created."
    reportObj.files = changedFiles;
    reportObj.needManualCheck = false;
    reportObj.category="Link";
    reportObj.filename="link";
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    printIt("Finished detecting uncompactible codes.", true);
}

/**
 * This function will detect the uasage of "current.phase in $L.file.save" in Process, DO, DS and formatctl.
 * Question: do we need to check Process? it seems no need.
 * Finally it seems we donot need to check for this usage, because the behavior change in 940 is for PD auto-transition, then
 *  . for non-PD, previous they do not use PD auto-transition, no impact.
 *  . for PD CP3, PD change module uses manual transition, no impact.
 *  . for PD CP4, it impacts the help desk modules which use auto-transition, it seems it is the scope of 940 to handle it, but not this PD wrapper code migration.
 */
function checkSavedRecordUsage() {
    var incStr = "current.phase in $L.file.save";

    var resultProcess = checkUsageInProcess(incStr, null, null, null);
    for(var process in resultProcess) {
        printIt("--&gt; Process:" + process);
        var expressions = resultProcess[process];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

    var resultDS = checkUsageInDisplayScreen(incStr, null, null, null);
    for(var ds in resultDS) {
        printIt("--&gt; DisplayScreen:" + ds);
        var expressions = resultDS[ds];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

    var resultDO = checkUsageInDisplayOption(incStr, null, null, null);
    for(var ddo in resultDO) {
        printIt("--&gt; DisplayOption:" + ddo);
        var expressions = resultDO[ddo];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

    var resultFC = checkUsageInFormatctrl(incStr, null, null, null);
    for(var fc in resultFC) {
        printIt("--&gt; formatctrl:" + fc);
        var expressions = resultFC[fc];
        for(var i=0, len=expressions.length; i&lt;len; i++) {
            printIt("     --&gt; expression:" + expressions[i]);
        }
    }

}

/**
 * Check the usage in Process for each line.
 * Currently check in JS is not supported.
 * 
 * @param {String}
 *            expIncStr - the include string in RAD expression.
 * @param {String}
 *            expExcStr - the exclude string in RAD expression.
 * @param {String}
 *            jsIncPattenStrs - the include array of the patten string in JS.
 * @param {String}
 *            jsExcPattenStrs - the exclude array of the patten string in JS.
 * 
 * @return object with the process name as key and process.
 */
function checkUsageInProcess(expIncStr, expExcStr, jsIncPattenStrs, jsExcPattenStrs) {
    var retObj = {};
    var process = new SCFile("Process", SCFILE_READONLY);
    var rc = process.doSelect("true");
    while(rc == RC_SUCCESS) {
        // pre expression
        var arr = existUsageInExpressions(process["pre.expressions"], expIncStr, expExcStr);
        if(null!=arr &amp;&amp; arr.length&gt;0) {
            retObj[process.process + "-&gt;pre.expressions"] = arr;
        }
        // post expression
        arr = existUsageInExpressions(process["post.expressions"], expIncStr, expExcStr);
        if(null!=arr &amp;&amp; arr.length&gt;0) {
            retObj[process.process + "-&gt;post.expressions"] = arr;
        }
        // RAD -&gt; pre/post expression
        var rads = process["rad"];
        if(null!=rads) {
            for(var radIdx=0, len=rads.length(); radIdx&lt;len; radIdx++) {
                var rad = rads[radIdx];
                if(rad==null) {
                    continue;
                }
                arr = existUsageInExpressions(rad["pre.rad.expressions"], expIncStr, expExcStr);
                if(null!=arr &amp;&amp; arr.length&gt;0) {
                     retObj[process.process + " RAD application " + rad.application + "-&gt;pre.rad.expressions"] = arr;
                }
                arr = existUsageInExpressions(rad["post.rad.expressions"], expIncStr, expExcStr);
                if(null!=arr &amp;&amp; arr.length&gt;0) {
                     retObj[process.process + " RAD application " + rad.application + "-&gt;post.rad.expressions"] = arr;
                }
            }
        }

        rc = process.getNext();
    }

    return retObj;
}

/**
 * Check the usage in DS for each line.
 * Currently check in JS is not supported.
 * 
 * @param {String}
 *            expIncStr - the include string in RAD expression.
 * @param {String}
 *            expExcStr - the exclude string in RAD expression.
 * @param {String}
 *            jsIncPattenStrs - the include array of the patten string in JS.
 * @param {String}
 *            jsExcPattenStrs - the exclude array of the patten string in JS.
 * 
 * @return object with the process name as key and process.
 */
function checkUsageInDisplayScreen(expIncStr, expExcStr, jsIncStr, jsExcStr) {
    var retObj = {};
    var displayscreen = new SCFile("displayscreen", SCFILE_READONLY);
    var rc = displayscreen.doSelect("true");
    while(rc == RC_SUCCESS) {
        // pre expression
        var arr = existUsageInExpressions(displayscreen["expressions"], expIncStr, expExcStr);
        if(null!=arr &amp;&amp; arr.length&gt;0) {
            retObj["screen.id"] = arr;
        }

        rc = displayscreen.getNext();
    }

    return retObj;
}

/**
 * Check the usage in DO for each line.
 * Currently check in JS is not supported.
 * 
 * @param {String}
 *            expIncStr - the include string in RAD expression.
 * @param {String}
 *            expExcStr - the exclude string in RAD expression.
 * @param {String}
 *            jsIncPattenStrs - the include array of the patten string in JS.
 * @param {String}
 *            jsExcPattenStrs - the exclude array of the patten string in JS.
 * 
 * @return object with the process name as key and process.
 */
function checkUsageInDisplayOption(expIncStr, expExcStr, jsIncStr, jsExcStr) {
    var retObj = {};
    var displayoption = new SCFile("displayoption", SCFILE_READONLY);
    var rc = displayoption.doSelect("true");
    while(rc == RC_SUCCESS) {
        // pre expression
        var arr = existUsageInExpressions(displayoption["post.expressions"], expIncStr, expExcStr);
        if(null!=arr &amp;&amp; arr.length&gt;0) {
            retObj[displayoption["screen.id"] + "-&gt;post.expressions"] = arr;
        }
        // post expression
        arr = existUsageInExpressions(displayoption["post.rad.expressions"], expIncStr, expExcStr);
        if(null!=arr &amp;&amp; arr.length&gt;0) {
            retObj[displayoption["screen.id"] + "-&gt;post.rad.expressions"] = arr;
        }

        rc = displayoption.getNext();
    }

    return retObj;
}

/**
 * Check the usage in FC for each line.
 * Currently check in JS is not supported.
 * 
 * @param {String}
 *            expIncStr - the include string in RAD expression.
 * @param {String}
 *            expExcStr - the exclude string in RAD expression.
 * @param {String}
 *            jsIncPattenStrs - the include array of the patten string in JS.
 * @param {String}
 *            jsExcPattenStrs - the exclude array of the patten string in JS.
 * 
 * @return object with the process name as key and process.
 */
function checkUsageInFormatctrl(expIncStr, expExcStr, jsIncStr, jsExcStr) {
    var retObj = {};
    var fc = new SCFile("formatctrl", SCFILE_READONLY);
    var rc = fc.doSelect("true");
    while(rc == RC_SUCCESS) {
        //init.expr
        var arr = existUsageInExpressions(fc["init.expr"], expIncStr, expExcStr);
        if(null!=arr &amp;&amp; arr.length&gt;0) {
            retObj[fc["name"] + "-&gt;init.expr"] = arr;
        }

        // qbeformats
        var qbeformats = fc["qbeformats"];
        if(null!=qbeformats) {
            for(var i=0, len=qbeformats.length(); i&lt;len; i++) {
                var qbe = qbeformats[i];
                if(existUsageInExpression(qbe["qbe.conditions"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;qbeformats[" + i + "]-&gt;qbe.conditions"] = [system.functions.str(qbe["qbe.conditions"])];
                }
            }
        }
        
        // views
        var views = fc["views"];
        if(null!=views) {
            for(var i=0, len=views.length(); i&lt;len; i++) {
                var view = views[i];
                if(existUsageInExpression(view["view.conditions"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;view[" + i + "]-&gt;view.conditions"] = [system.functions.str(view["view.conditions"])];
                }
            }
        }
        
        // queries
        var queries = fc["queries"];
        if(null!=queries) {
            for(var i=0, len=queries.length(); i&lt;len; i++) {
                var query = queries[i];
                if(existUsageInExpression(query["query"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;query"] = [system.functions.str(query["query"])];
                }
                if(existUsageInExpression(query["required"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;required"] = [system.functions.str(query["required"])];
                }
                if(existUsageInExpression(query["display"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;display"] = [system.functions.str(query["display"])];
                }
                if(existUsageInExpression(query["query.init"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;query.init"] = [system.functions.str(query["query.init"])];
                }
                if(existUsageInExpression(query["add"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;add"] = [system.functions.str(query["add"])];
                }
                if(existUsageInExpression(query["update"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;update"] = [system.functions.str(query["update"])];
                }
                if(existUsageInExpression(query["delete"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;queries[" + i + "]-&gt;delete"] = [system.functions.str(query["delete"])];
                }
            }
        }
        
        // calculations
        var calculations = fc["calculations"];
        if(null!=calculations) {
            for(var i=0, len=calculations.length(); i&lt;len; i++) {
                var calculation = calculations[i];
                if(existUsageInExpression(calculation["calculation"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;calculation[" + i + "]-&gt;calculation"] = [system.functions.str(calculation["calculation"])];
                }
                if(existUsageInExpression(calculation["display"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;calculation[" + i + "]-&gt;display"] = [system.functions.str(calculation["display"])];
                }
                if(existUsageInExpression(calculation["calc.init"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;calculation[" + i + "]-&gt;calc.init"] = [system.functions.str(calculation["calc.init"])];
                }
                if(existUsageInExpression(calculation["add"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;calculation[" + i + "]-&gt;add"] = [system.functions.str(calculation["add"])];
                }
                if(existUsageInExpression(calculation["update"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;calculation[" + i + "]-&gt;update"] = [system.functions.str(calculation["update"])];
                }
                if(existUsageInExpression(calculation["delete"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;calculation[" + i + "]-&gt;delete"] = [system.functions.str(calculation["delete"])];
                }
            }
        }

        // javascripts
        var javascripts = fc["javascript"];
        if(null!=javascripts) {
            for(var i=0, len=javascripts.length(); i&lt;len; i++) {
                var javascript = javascripts[i];
                if(existUsageInExpression(javascript["javascript.display"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;javascript[" + i + "]-&gt;javascript.display"] = [system.functions.str(javascript["javascript.display"])];
                }
                if(existUsageInExpression(javascript["javascript.init"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;javascript[" + i + "]-&gt;javascript.init"] = [system.functions.str(javascript["javascript.init"])];
                }
                if(existUsageInExpression(javascript["javascript.add"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;javascript[" + i + "]-&gt;javascript.add"] = [system.functions.str(javascript["javascript.add"])];
                }
                if(existUsageInExpression(javascript["javascript.update"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;javascript[" + i + "]-&gt;javascript.update"] = [system.functions.str(javascript["javascript.update"])];
                }
                if(existUsageInExpression(javascript["javascript.delete"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;javascript[" + i + "]-&gt;javascript.delete"] = [system.functions.str(javascript["javascript.delete"])];
                }
            }
        }
        
        // validations
        var validations = fc["validations"];
        if(null!=validations) {
            for(var i=0, len=validations.length(); i&lt;len; i++) {
                var validation = validations[i];
                if(existUsageInExpression(validation["validation"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;validation[" + i + "]-&gt;validation"] = [system.functions.str(validation["validation"])];
                }
                if(existUsageInExpression(validation["display"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;validation[" + i + "]-&gt;display"] = [system.functions.str(validation["display"])];
                }
                if(existUsageInExpression(validation["val.init"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;validation[" + i + "]-&gt;val.init"] = [system.functions.str(validation["val.init"])];
                }
                if(existUsageInExpression(validation["add"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;validation[" + i + "]-&gt;add"] = [system.functions.str(validation["add"])];
                }
                if(existUsageInExpression(validation["update"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;validation[" + i + "]-&gt;update"] = [system.functions.str(validation["update"])];
                }
                if(existUsageInExpression(validation["delete"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;validation[" + i + "]-&gt;delete"] = [system.functions.str(validation["delete"])];
                }
            }
        }
        
        // subroutines
        var subroutines = fc["subroutines"];
        if(null!=subroutines) {
            for(var i=0, len=subroutines.length(); i&lt;len; i++) {
                var subroutine = subroutines[i];
                if(existUsageInExpression(subroutine["before"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;subroutine[" + i + "]-&gt;before"] = [system.functions.str(subroutine["before"])];
                }
                if(existUsageInExpression(subroutine["display"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;subroutine[" + i + "]-&gt;display"] = [system.functions.str(subroutine["display"])];
                }
                if(existUsageInExpression(subroutine["sub.init"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;subroutine[" + i + "]-&gt;sub.init"] = [system.functions.str(subroutine["sub.init"])];
                }
                if(existUsageInExpression(subroutine["add"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;subroutine[" + i + "]-&gt;add"] = [system.functions.str(subroutine["add"])];
                }
                if(existUsageInExpression(subroutine["update"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;subroutine[" + i + "]-&gt;update"] = [system.functions.str(subroutine["update"])];
                }
                if(existUsageInExpression(subroutine["delete"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;subroutine[" + i + "]-&gt;delete"] = [system.functions.str(subroutine["delete"])];
                }
            }
        }
        
        // add.options
        var addOptions = fc["add.options"];
        if(null!=addOptions) {
            for(var i=0, len=addOptions.length(); i&lt;len; i++) {
                var addOption = addOptions[i];
                if(existUsageInExpression(addOption["condition"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;add.options[" + i + "]-&gt;condition"] = [system.functions.str(addOption["condition"])];
                }
                if(existUsageInExpression(addOption["reset"], expIncStr, expExcStr)) {
                    retObj[fc["name"] + "-&gt;add.options[" + i + "]-&gt;reset"] = [system.functions.str(addOption["reset"])];
                }
            }
        }
        
        // privileges
        if(existUsageInExpression(fc["db.add"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.add"] = [system.functions.str(fc["db.add"])];
        }
        if(existUsageInExpression(fc["db.update"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.update"] = [system.functions.str(fc["db.update"])];
        }
        if(existUsageInExpression(fc["db.delete"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.delete"] = [system.functions.str(fc["db.delete"])];
        }
        if(existUsageInExpression(fc["db.find"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.find"] = [system.functions.str(fc["db.find"])];
        }
        if(existUsageInExpression(fc["db.print"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.print"] = [system.functions.str(fc["db.print"])];
        }
        if(existUsageInExpression(fc["database.access"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;database.access"] = [system.functions.str(fc["database.access"])];
        }
        if(existUsageInExpression(fc["db.query"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.query"] = [system.functions.str(fc["db.query"])];
        }
        if(existUsageInExpression(fc["db.count"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.count"] = [system.functions.str(fc["db.count"])];
        }
        if(existUsageInExpression(fc["db.validity"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.validity"] = [system.functions.str(fc["db.validity"])];
        }
        if(existUsageInExpression(fc["db.views"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.views"] = [system.functions.str(fc["db.views"])];
        }
        if(existUsageInExpression(fc["db.expand"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.expand"] = [system.functions.str(fc["db.expand"])];
        }
        if(existUsageInExpression(fc["db.load"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.load"] = [system.functions.str(fc["db.load"])];
        }
        if(existUsageInExpression(fc["db.load"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.load"] = [system.functions.str(fc["db.load"])];
        }
        if(existUsageInExpression(fc["db.unload"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.unload"] = [system.functions.str(fc["db.unload"])];
        }
        if(existUsageInExpression(fc["db.mass.add"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.mass.add"] = [system.functions.str(fc["db.mass.add"])];
        }
        if(existUsageInExpression(fc["db.mass.update"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.mass.update"] = [system.functions.str(fc["db.mass.update"])];
        }
        if(existUsageInExpression(fc["db.complex"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.complex"] = [system.functions.str(fc["db.complex"])];
        }
        if(existUsageInExpression(fc["db.template"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.template"] = [system.functions.str(fc["db.template"])];
        }
        if(existUsageInExpression(fc["db.mass.delete"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.mass.delete"] = [system.functions.str(fc["db.mass.delete"])];
        }
        if(existUsageInExpression(fc["db.reset"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.reset"] = [system.functions.str(fc["db.reset"])];
        }
        if(existUsageInExpression(fc["db.regen"], expIncStr, expExcStr)) {
            retObj[fc["name"] + "-&gt;db.regen"] = [system.functions.str(fc["db.regen"])];
        }

        rc = fc.getNext();
    }

    return retObj;
}

/**
 * Check whethe the usage in Process for each expression exists or not.
 * 
 * @param {array of expression}
 *            exps - array of .
 * @param {String}
 *            incStr - the include string in RAD expression.
 * @param {String}
 *            excStr - the exclude string in RAD expression.
 * 
 * @return array of the lines matched.
 */
function existUsageInExpressions(exps, incStr, excStr) {
    var retArray = [];
    if(null==exps) {
         return retArray;
    }

    for(var i=0, len=exps.length(); i&lt;len; i++) {
        if(existUsageInExpression(exps[i], incStr, excStr)) {
            var str = "line#" + (i+1) + ":" + system.functions.str(exps[i]);
            retArray.push(str);
        }
    }

    return retArray;
}

/**
 * Check whethe the usage in Process for each expression exists or not.
 * 
 * @param {expression}
 *            exp - the expression.
 * @param {String}
 *            incStr - the include string in RAD expression.
 * @param {String}
 *            excStr - the exclude string in RAD expression.
 * 
 * @return boolean true if matches.
 */
function existUsageInExpression(exp, incStr, excStr) {
    if(null==exp) {
         return false;
    }

    var str = system.functions.str(exp);

    if(str!=null &amp;&amp; str.indexOf(incStr)&gt;=0) {

        if(excStr==null || str.indexOf(excStr)&lt;0) {

            return true;
        }
    }

    return false;
}

/**
 * Write the migration log to log file.
 * @param {boolean}
 *            isAlsoConsole - whether also print the log to console.
 * 
 */
function printIt(content, isAlsoConsole) {
    if(isAlsoConsole===true) {
        print(content);
    }
    system.functions.log(content);
}


/**
 * This method is used to insert the triggers to sync the PD category data back to the legacy category data for Incident , Service Desk and Problem modules
 */
function synCategoryData(){
  printIt("Start migrating the configuration of syncing category data back...", true);

  var AFTER_ADD = 2;
  var AFTER_UPDATED = 4;
  var AFTER_DELETE = 6;
  
//add triggers to sync imCategory data to category tables
  addTrigger("sync.added.imcategory","imCategory",AFTER_ADD,"lib.SyncPDCategoryData.syncCategoryData(record);");
  addTrigger("sync.updated.imcategory","imCategory",AFTER_UPDATED,"lib.SyncPDCategoryData.syncCategoryData(record,oldrecord);");
  addTrigger("sync.deleted.imcategory","imCategory",AFTER_DELETE,"lib.SyncPDCategoryData.deleteCategoryData(record);");
  

  //add triggers to sync imSubCategory data to subcategory tables 
  addTrigger("sync.added.imsubcategory","imSubcategory",AFTER_ADD,"lib.SyncPDCategoryData.syncSubCategoryData(record);");
  addTrigger("sync.updated.imsubcategory","imSubcategory",AFTER_UPDATED,"lib.SyncPDCategoryData.syncSubCategoryData(record,oldrecord);");
  addTrigger("sync.deleted.imsubcategory","imSubcategory",AFTER_DELETE,"lib.SyncPDCategoryData.deleteSubCategoryData(record);");

  //add triggers to sync imArea data to product.type tables 
  addTrigger("sync.added.imArea","imArea",AFTER_ADD,"lib.SyncPDCategoryData.syncAreaData(record);");
  addTrigger("sync.updated.imArea","imArea",AFTER_UPDATED,"lib.SyncPDCategoryData.syncAreaData(record,oldrecord);");
  addTrigger("sync.deleted.imArea","imArea",AFTER_DELETE,"lib.SyncPDCategoryData.deleteAreaData(record);");
  
  
    //add triggers to sync sdCategory data to category tables
  addTrigger("sync.added.sdcategory","sdCategory",AFTER_ADD,"lib.SyncPDCategoryData.syncCategoryData(record);");
  addTrigger("sync.updated.sdcategory","sdCategory",AFTER_UPDATED,"lib.SyncPDCategoryData.syncCategoryData(record,oldrecord);");
  addTrigger("sync.deleted.sdcategory","sdCategory",AFTER_DELETE,"lib.SyncPDCategoryData.deleteCategoryData(record);");
  

  //add triggers to sync sdSubCategory data to subcategory tables 
  addTrigger("sync.added.sdsubcategory","sdSubcategory",AFTER_ADD,"lib.SyncPDCategoryData.syncSubCategoryData(record);");
  addTrigger("sync.updated.sdsubcategory","sdSubcategory",AFTER_UPDATED,"lib.SyncPDCategoryData.syncSubCategoryData(record,oldrecord);");
  addTrigger("sync.deleted.sdsubcategory","sdSubcategory",AFTER_DELETE,"lib.SyncPDCategoryData.deleteSubCategoryData(record);");

  //add triggers to sync sdArea data to product.type tables 
  addTrigger("sync.added.sdArea","sdArea",AFTER_ADD,"lib.SyncPDCategoryData.syncAreaData(record);");
  addTrigger("sync.updated.sdArea","sdArea",AFTER_UPDATED,"lib.SyncPDCategoryData.syncAreaData(record,oldrecord);");
  addTrigger("sync.deleted.sdArea","sdArea",AFTER_DELETE,"lib.SyncPDCategoryData.deleteAreaData(record);");
  
  
  
   //add triggers to sync pbmCategory data to category tables
  addTrigger("sync.added.pbmcategory","pbmCategory",AFTER_ADD,"lib.SyncPDCategoryData.syncCategoryData(record);");
  addTrigger("sync.updated.pbmcategory","pbmCategory",AFTER_UPDATED,"lib.SyncPDCategoryData.syncCategoryData(record,oldrecord);");
  addTrigger("sync.deleted.pbmcategory","pbmCategory",AFTER_DELETE,"lib.SyncPDCategoryData.deleteCategoryData(record);");
  

  //add triggers to sync pbmSubCategory data to subcategory tables 
  addTrigger("sync.added.pbmsubcategory","pbmSubcategory",AFTER_ADD,"lib.SyncPDCategoryData.syncSubCategoryData(record);");
  addTrigger("sync.updated.pbmsubcategory","pbmSubcategory",AFTER_UPDATED,"lib.SyncPDCategoryData.syncSubCategoryData(record,oldrecord);");
  addTrigger("sync.deleted.pbmsubcategory","pbmSubcategory",AFTER_DELETE,"lib.SyncPDCategoryData.deleteSubCategoryData(record);");

  //add triggers to sync pbmArea data to product.type tables 
  addTrigger("sync.added.pbmArea","pbmArea",AFTER_ADD,"lib.SyncPDCategoryData.syncAreaData(record);");
  addTrigger("sync.updated.pbmArea","pbmArea",AFTER_UPDATED,"lib.SyncPDCategoryData.syncAreaData(record,oldrecord);");
  addTrigger("sync.deleted.pbmArea","pbmArea",AFTER_DELETE,"lib.SyncPDCategoryData.deleteAreaData(record);");
  
  
  
  
  //insert the customized fields dynamically into the SyncPDCategoryData ScriptLibrary
  var oobCategoryFields = ["name", "activity", "open.format", "update.format", "close.format", "count",
	 "alert1", "alert2", "alert3", "reassign", "default.assign", "avail.post",
	 "qbe.format", "dl.alert", "dl.group", "alert1.expression", "alert2.expression",
	 "alert3.expression", "dl.expression", "reass.expression", "print.override", "print.open",
	 "print.open.format", "print.update", "print.update.format", "print.close", 
	 "print.close.format", "alert.pages", "initial.format", "check.duplicates", 
	 "check.parents", "device.types", "include.unexpired", "expires.after", 
	 "script", "browse.format", "review.print.formats", "open.print.formats", 
	 "update.print.formats", "close.print.formats", "assignment.expression", 
	 "category.format", "wdClsDuration", "wdUD1", "wdUD2", "wdPriority", 
	 "wdClsCustSatisfaction", "wdClsActDuration", "wdClsRoot", "wdClsLevel", 
	 "wdClsParent", "wdClsInflatePriority", "wdClsTimeStamp", "wdTips", "print.format", 
	 "active", "sysmodcount", "sysmoduser", "sysmodtime", "copy.open.link", "company", 
	 "engine.alerts", "approvals"];
  insertCustFieldsForSync("category",oobCategoryFields);
  
  var oobSubcategoryFields = ["category", "subcategory", "subcategory.name", "description", "company",
      "active", "sysmodcount", "sysmoduser", "sysmodtime"];
  insertCustFieldsForSync("subcategory",oobSubcategoryFields);
  
  
  var oobAreaFields = ["category", "subcategory", "product.type", "description", "company", "active", "sysmodcount", "sysmodtime", "sysmoduser"];
  insertCustFieldsForSync("producttype",oobAreaFields);

  printIt("Finished migrating the configuration of syncing category data back.", true);
}

/**
 * This method is used to add the triggers into db 
 * 
 * @param {String}
 *            triggerName - The name of the trigger to be added
 * @param {String}
 *            tableName - The table name on which trigger will be applied
 * @param {String}
 *            triggerType - The type of the trigger
 * @param {String}
 *            calledScript - The script method will be called for the trigger
 * 
 * @return void
 */
function addTrigger(triggerName, tableName, triggerType,calledScript){
  var trigger = new SCFile("triggers");
  trigger.trigger_name = triggerName;
  trigger.table_name = tableName;
  trigger.trigger_type = triggerType;
  trigger.javascript = calledScript;
  trigger.doSave();
    addMigrationPatchRecord("triggers", trigger, trigger.trigger_name, false);
}


/**
 * This method is used to insert the customized fields list into SyncPDCategoryData script file . For example insert " categoryCustFields=["custField1"];" before the line contains 
 * /**end to insert customized field list for category during the PD migration** 
 * @param {String}
 *            tableName - The table name 
 * @param {String}
 *            oobFieldList - The OOB field list for the table specified with the tableName param
 * 
 * @return void
 */
function insertCustFieldsForSync(tableName, oobFieldList){
   var customizedFieldList = getCustomizedFieldList(tableName, oobFieldList);
   if (customizedFieldList.length&gt;0){
       var scriptLib= new SCFile("ScriptLibrary");
	   scriptLib.doSelect("name=\"SyncPDCategoryData\"");
	   var script = scriptLib.script;
	   var lines = script.split("\n");
	   var initialLines=lines.length;
	   var addingLine="";
	   if (tableName == "category"){
	      addingLine = "  categoryCustFields=[";
	   }else if(tableName == "subcategory"){
	      addingLine = "  subcategoryCustFields=[";
	   }else if(tableName == "producttype"){
	      addingLine = "  areaCustFields=[";
	   }
	   for (var i=0; i&lt;customizedFieldList.length ; i++){
	        addingLine = addingLine + "\""+ customizedFieldList[i] + "\"";
	        if(i == customizedFieldList.length -1){
	           addingLine = addingLine + "];";
	        }else {
	           addingLine = addingLine + ",";
	        }
	   }
	   
	   var insertPoint = lib.ArrayUtil.indexOf(lines, "/**end to insert customized field list for "+tableName+" during the PD migration**/");
	   if (insertPoint &gt; 0 &amp;&amp; !lib.ArrayUtil.contains(lines, addingLine)) {
	          lines.splice(insertPoint, 0, addingLine);
	   }
	   
	   if(initialLines&lt;lines.length){
	            scriptLib.script = lines.join("\n");
	            scriptLib.doSave();
	   }
   }

}

/**
 * This method is used to get the customized field list for a table compared with the OOB field list
 * 
 * @param {String}
 *            tableName - The table name 
 * @param {String}
 *            oobFieldList - The OOB field list for the table specified with the tableName param
 * 
 * @return the customizedFieldList
 */
function getCustomizedFieldList(tableName, oobFieldList){
  var start = new Date();
  var fieldList = [];
  var fdbdict = new SCFile("dbdict",SCFILE_READONLY);
  fdbdict.doSelect("name=\"" + tableName + "\"");
  var length = fdbdict.field.length();
  for (var i=0; i &lt;length; i++) { 
        if(fdbdict.field[i].level ==1 &amp;&amp; !lib.ArrayUtil.contains(oobFieldList,fdbdict.field[i].name)){
          fieldList.push(fdbdict.field[i].name);
        } 
  }
     
  return fieldList;
}



function createStage1Alert(category, alertList) {
    if (category.alert1 != null || category.alert1_expression != null) {
        var alertDef = new SCFile("AlertDef");
        alertDef.name = "Incident Alert Stage 1" + getAlertNameSuffix(category);
        alertDef.description[0] = alertDef.name;
        alertDef['alert.type'] = "none";
        alertDef['sched.condition'] = _val("nullsub(status in $L.file, \"\")~={\"DEADLINE ALERT\", \"closed\", \"resolved\"} and category in $L.file=\"" + category.name + "\"", 10);
        alertDef['sched.class'] = "alert";
        alertDef['alert.condition'] = _val("nullsub(status in $L.file, \"\")~={\"DEADLINE ALERT\", \"closed\", \"resolved\"} and flag in $L.file=true", 10);
        alertDef['calc.type'] = "expression";
        if (category.alert1_expression != null) {
            alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.alert1_expression)), 11);
        } else {
            alertDef['calc.expression'] = _parse("alert.time in $L.file=tod()+'" + system.functions.str(category.alert1) + "'", 11);
        }
        alertDef['calc.expression'] = _parse(system.functions.str(alertDef['calc.expression']) + ";$L.alert.time=alert.time in $L.file", 11);
        alertDef['statements'] = [_parse("status in $L.file=\"alert stage 1\"", 11), _parse("alert1 in $L.file=true", 11)];
        alertDef['format.control'] = getAlertFCName(category);
        alertDef.doSave();
        addMigrationPatchRecord("AlertDef", alertDef, alertDef["name"], false);
        alertList.push(alertDef.name);
    }
}


function createStage2Alert(category, alertList) {
    if ((category.alert1 != null || category.alert1_expression != null) &amp;&amp; (category.alert2 != null || category.alert2_expression != null)) {
        var alertDef = new SCFile("AlertDef");
        alertDef.name = "Incident Alert Stage 2" + getAlertNameSuffix(category);
        alertDef.description[0] = alertDef.name;
        alertDef['alert.type'] = "none";
        alertDef['sched.condition'] = _val("nullsub(status in $L.file, \"\")~={\"DEADLINE ALERT\", \"closed\", \"resolved\"} and category in $L.file=\"" + category.name + "\"", 10);
        alertDef['sched.class'] = "alert";
        alertDef['alert.condition'] = _val(" nullsub(status in $L.file, \"\")=\"alert stage 1\" and flag in $L.file=true", 10);
        alertDef['calc.type'] = "expression";
        if (category.alert2_expression != null) {
            alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.alert2_expression)), 11);
        } else {
            if (category.alert1_expression != null) {
                alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.alert1_expression)) + ";alert.time in $L.file=alert.time in $L.file+'" + system.functions.str(category.alert2) + "'", 11);
            } else {
                alertDef['calc.expression'] = _parse("alert.time in $L.file=tod()+'" + system.functions.str(category.alert1) + "'+'" + system.functions.str(category.alert2) + "'", 11);
            }
        }
        alertDef['calc.expression'] = _parse(system.functions.str(alertDef['calc.expression']) + ";$L.alert.time=alert.time in $L.file", 11);
        alertDef['statements'] = [_parse("status in $L.file=\"alert stage 2\";$L.void=jscall(\"alertStageService.stageReassignment\",$L.file)", 11), _parse("alert2 in $L.file=true", 11)];
        alertDef['format.control'] = getAlertFCName(category);
        alertDef.doSave();
        addMigrationPatchRecord("AlertDef", alertDef, alertDef["name"], false);
        alertList.push(alertDef.name);
    }
}


function createStage3Alert(category, alertList) {
    if ((category.alert1 != null || category.alert1_expression != null) &amp;&amp; (category.alert2 != null || category.alert2_expression != null) &amp;&amp; (category.alert3 != null || category.alert3_expression != null)) {
        var alertDef = new SCFile("AlertDef");
        alertDef.name = "Incident Alert Stage 3" + getAlertNameSuffix(category);
        alertDef.description[0] = alertDef.name;
        alertDef['alert.type'] = "none";
        alertDef['sched.condition'] = system.functions.val(" nullsub(status in $L.file, \"\")~={\"DEADLINE ALERT\", \"closed\", \"resolved\"} and category in $L.file=\"" + category.name + "\"", 10);
        alertDef['sched.class'] = "alert";
        alertDef['alert.condition'] = system.functions.val(" nullsub(status in $L.file, \"\")=\"alert stage 2\" and flag in $L.file=true", 10);
        alertDef['calc.type'] = "expression";
        if (category.alert3_expression != null) {
            alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.alert3_expression)), 11);
        } else {
            if (category.alert2_expression != null) {
                alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.alert2_expression)) + ";alert.time in $L.file=alert.time in $L.file+'" + system.functions.str(category.alert3) + "'", 11);
            } else {
                if (category.alert1_expression != null) {
                    alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.alert1_expression)) + ";alert.time in $L.file=alert.time in $L.file+'" + system.functions.str(category.alert2) + "'+'" + system.functions.str(category.alert3) + "'", 11);
                } else {
                    alertDef['calc.expression'] = _parse("alert.time in $L.file=tod()+'" + system.functions.str(category.alert1) + "'+'" + system.functions.str(category.alert2) + "'+'" + system.functions.str(category.alert3) + "'", 11);
                }
            }
        }
        alertDef['calc.expression'] = _parse(system.functions.str(alertDef['calc.expression']) + ";$L.alert.time=alert.time in $L.file", 11);
        alertDef['statements'] = [_parse("status in $L.file=\"alert stage 3\";$L.void=jscall(\"alertStageService.stageReassignment\",$L.file)", 11), _parse("alert3 in $L.file=true", 11)];
        alertDef['format.control'] = getAlertFCName(category);
        alertDef.doSave();
        addMigrationPatchRecord("AlertDef", alertDef, alertDef["name"], false);
        alertList.push(alertDef.name);
    }
}

function createDeadlineAlert(category, alertList) {
    if (category.dl_alert != null || category.dl_expression != null) {
        var alertDef = new SCFile("AlertDef");
        alertDef.name = "Incident Deadline" + getAlertNameSuffix(category);
        alertDef.description[0] = alertDef.name;
        alertDef['alert.type'] = "none";
        alertDef['sched.condition'] = _val("nullsub(status in $L.file, \"\")~={\"DEADLINE ALERT\", \"closed\", \"resolved\"} and category in $L.file=\"" + category.name + "\"", 10);
        alertDef['sched.class'] = "alert";
        alertDef['alert.condition'] = _val("nullsub(status in $L.file, \"\")~={\"DEADLINE ALERT\", \"closed\", \"resolved\"} and flag in $L.file=true", 10);
        alertDef['calc.type'] = "expression";
        if (category.dl_expression != null) {
            alertDef['calc.expression'] = _parse(fixAlertExpression(system.functions.str(category.dl_expression)), 11);
        } else {
            alertDef['calc.expression'] = _parse("deadline.alert in $L.file=nullsub(reopen.time in $L.file, open.time in $L.file)+'" + system.functions.str(category.dl_alert) + "'", 11);
        }
        alertDef['calc.expression'] = _parse(system.functions.str(alertDef['calc.expression']) + ";$L.alert.time=deadline.alert in $L.file;if (not  (null($L.alert.time)) and $L.alert.time&lt;tod()+'00:00:10') then ($L.alert.time=tod()+'00:00:10')", 11);
        alertDef['statements'] = [_parse("status in $L.file=\"DEADLINE ALERT\";$L.void=jscall(\"alertStageService.deadlineReassignment\",$L.file,\"" + category.dl_group + "\")", 11), _parse("deadline in $L.file=true", 11)];
        alertDef['format.control'] = getAlertFCName(category);
        alertDef.doSave();
        addMigrationPatchRecord("AlertDef", alertDef, alertDef["name"], false);
        alertList.push(alertDef.name);
    }
}

function getAlertNameSuffix(category) {
    return " for " + category.name;
}

function getAlertFCName(category) {
    var fc = new SCFile("formatctrl");
    var sql = "name=\"IM." + category.name + ".alerts\"";
    if (RC_SUCCESS == fc.doSelect(sql)) {
        return "IM." + category.name + ".alerts";
    } else {
        var sql = "name=\"IM.alerts\"";
        if (RC_SUCCESS == fc.doSelect(sql)) {
            return "IM.alerts";
        }
    }

    return null;
}

function addAlertToWorkflow(alertList) {
    var wkFlowPhase = $("WorkflowPhase").select("workflowName=\"" + PD_CODE_MIGRATION_WF_PREFIX + "Incident" + "\" and phaseName=\"" + PHASE_NAME_INPROGRESS + "\"").uniqueResult();

    if (wkFlowPhase &amp;&amp; alertList.length &gt; 0) {
        for (var i = 0; i &lt; alertList.length; ++i) {
            if (alertList[i] &amp;&amp; alertList[i] != "" &amp;&amp; system.functions.index(alertList[i], wkFlowPhase.alerts) &lt; 1) {
                wkFlowPhase.alerts.push(alertList[i]);
            }
        }


        if (system.functions.index("im.alert.stage.processing", wkFlowPhase.onUpdateRules) &lt; 1) {
            wkFlowPhase.onUpdateRules.push("im.alert.stage.processing");
        }

        if (wkFlowPhase.alertsReset === null) {
            wkFlowPhase.alertsResetXML = TURE_CONDITION_XML;
            wkFlowPhase.alertsResetDesc = TURE_CONDITION_DESC;
        }

        wkFlowPhase.doUpdate();
    }
}

function fixAlertExpression(expression) {
    expression = expression.replace(/\$file/g, "$L.file");
    return expression;
}

function migrateCategoryAlert() {

    printIt("Start migrating category based alerts...", true);
    var migratedAlerts = [];
    var engineAlerts = [];
    var migratedCategories = $("imCategory").select("workflow=\"" + PD_CODE_MIGRATION_WF_PREFIX + "Incident\"").list();
    for (var i = 0; i &lt; migratedCategories.length; ++i) {

        var legacyCategory = $("category").select("name=\"" + migratedCategories[i].name + "\"").uniqueResult();
        if (legacyCategory) {
            //migrate category based alerts
            createStage1Alert(legacyCategory, migratedAlerts);
            createStage2Alert(legacyCategory, migratedAlerts);
            createStage3Alert(legacyCategory, migratedAlerts);
            createDeadlineAlert(legacyCategory, migratedAlerts);

            //migrate standard alerts
            engineAlerts = engineAlerts.concat(legacyCategory.engine_alerts.toArray());

        }
    }

    addAlertToWorkflow(engineAlerts.concat(migratedAlerts));

    var reportObj = {};
    reportObj.title = "The following Alert Definition records are created based on the stage 1/2/3 and deadline configuration in legacy category to support incident escalation when no one updates the incident within a specified time:";
    reportObj.files = migratedAlerts;
    reportObj.category="Alert Definition";
    reportObj.filename="alertDef";
    
    
    SUMMARY_REPORT_OBJS.push(reportObj);

    printIt("Finish migrating category based alerts.", true);


}

function appendSDBGtransition(workflowName) {
    var workflow = $("Workflow").select("name=\"" + workflowName + "\" and tableName=\"incidents\"").uniqueResult();
    if (workflow) {
        workflow.backendTransition[0][5] = "event.linked";
        workflow.backendTransition[0][0] = PHASE_NAME_INPROGRESS;
        workflow.backendTransition[0][2] = "sd.set.open.linked";

        workflow.backendTransition[1][5] = "event.close";
        workflow.backendTransition[1][0] = "Closure";
        workflow.backendTransition[1][2] = "sd.set.closed";

        workflow.backendTransition[2][5] = "event.callback";
        workflow.backendTransition[2][0] = PHASE_NAME_INPROGRESS;
        workflow.backendTransition[2][2] = "sd.set.call.back";

        workflow.doUpdate();
    }
}

function backupProcess(processName) {
    var processBak = $("Process").select("process=\"" + processName + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
    if (null != processBak) { // the backup process already exists, ignore the backup
        printIt("The backup of the Process " + processName + " exists already, ignore the backup.", true);
    } else { // backup the process
        processBak = $("Process").select("process=\"" + processName + "\"").uniqueResult();
        processBak.process = processName + PD_CODE_MIGRATION_DISABLE_SUFFIX;
        processBak.doInsert();
        printIt("The Process " + processName + " is backuped to " + processName + PD_CODE_MIGRATION_DISABLE_SUFFIX, true);
    }
}

function fixIncidentChangeCategoryAction() {
    // find the DO "change Category" and disable it
    var displayoption = new SCFile("displayoption");
    var rc = displayoption.doSelect('screen.id="apm.edit.problem" and action="newcat" and default="Change Category"');
    var actionCondStr = null;
    if(rc == RC_SUCCESS) {
        if(displayoption["user.condition"]==null || system.functions.str(displayoption["user.condition"])=="") {
            displayoption["user.condition"] = false;//system.functions.parse('false', 11);
            displayoption["user.condition.txt"] = 'false';
            actionCondStr = system.functions.str(displayoption["condition"])
        } else {
            var userCondStr = system.functions.str(displayoption["user.condition"]);
            //displayoption["user.condition"] = system.functions.parse('(' + userCondStr + ') and false', 11);
            displayoption["user.condition"] = '(' + userCondStr + ') and false';
            displayoption["user.condition.txt"] = '(' + userCondStr + ') and false';
            actionCondStr = userCondStr;
        }
        var rc2 = displayoption.doUpdate();
        //print("rc2:" + rc2 + ", RCtoString(rc2):" + RCtoString(rc2));
        if(rc2 != RC_SUCCESS) {
            printIt("Update Display Option \"" + displayoption.id + "\" fail, the error string:" + RCtoString(rc2) + ", ignore adding the Action for it.");
            return;
        }
        addMigrationPatchRecord("displayoption", displayoption, displayoption["id"], false);


        var reportObj = {};
        reportObj.title = "The following displayoption records are disabled by setting the User Condition to false.";
        reportObj.files = [displayoption.id];
        reportObj.needManualCheck = false;
        reportObj.category = "Display Option";
        reportObj.filename = "displayoption";

        SUMMARY_REPORT_OBJS.push(reportObj);
    } else {
        printIt("Can not find the Display Option \"Change Category\", ignore adding the Action for it.");
        return;
    }

    //add change category action in workflow
    var pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "Incident";
    var wfPhase = $("WorkflowPhase").select("workflowName=\"" + pdMigratedWorkflowName + "\" and tableName=\"probsummary\" and phaseName=\"" + PHASE_NAME_INPROGRESS + "\"").uniqueResult();
    if (wfPhase) {
        wfPhase.action[0].action = "Change Category";
        wfPhase.action[0].actionName = "Change Category";
        wfPhase.action[0].actionId = "im.changeCategory";
        wfPhase.action[0].actionCondition = system.functions.parse(actionCondStr, 11);
        wfPhase.action[0].actionCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;&lt;operand type=\"expression\"&gt;&lt;Expression caption=\"\"&gt;\"" + system.functions.str(actionCondStr) + "\"&lt;/Expression&gt;&lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
        wfPhase.action[0].actionLoc = 2;
        wfPhase.action[0].actionOption = 280;
        wfPhase.action[0].actionLock = false;
        wfPhase.action[0].actionRunAction = null;
        wfPhase.action[0].actionCondDesc = "( Expression: " + system.functions.str(actionCondStr) + ")";
        wfPhase.action[0].actionMsgId = 1;
        wfPhase.doUpdate();
    } else {
        printIt("Can not find the Migrated Incident Workflow Phase \"" + PHASE_NAME_INPROGRESS + "\", ignore adding the Action for it.");
        return;
    }
}

function fixSDNewProcessing() {

    //1.provide Exit&amp;New for the migrated workflow interaction    
    var pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "ServiceDesk";
    var wfPhase = $("WorkflowPhase").select("workflowName=\"" + pdMigratedWorkflowName + "\" and tableName=\"incidents\" and phaseName=\"" + PHASE_NAME_INPROGRESS + "\"").uniqueResult();
    if (wfPhase) {
        wfPhase.initRules[0] = "sd.check.view.last.interaction";
        wfPhase.doUpdate();
    }
    var doData = '&lt;model name="displayoption" query="id=&amp;quot;cc.edit.incident_exitnew&amp;quot;"&gt;&lt;keys&gt;&lt;id sctype="string"&gt;cc.edit.incident_exitnew&lt;/id&gt;&lt;/keys&gt;&lt;instance recordid="cc.edit.incident_exitnew" uniquequery="id=&amp;quot;cc.edit.incident_exitnew&amp;quot;"&gt;&lt;screen.id type="string"&gt;cc.edit.incident&lt;/screen.id&gt;&lt;language type="string"&gt;ENG&lt;/language&gt;&lt;gui.option type="decimal"&gt;1&lt;/gui.option&gt;&lt;txt.option type="decimal"&gt;1&lt;/txt.option&gt;&lt;txt.bank type="decimal"&gt;1&lt;/txt.bank&gt;&lt;labels sctype="structure"&gt;&lt;default type="string"&gt;Exit &amp;amp; New&lt;/default&gt;&lt;balloon type="string"&gt;Exit &amp;amp; New&lt;/balloon&gt;&lt;/labels&gt;&lt;condition type="operator"&gt;$L.tableAccess.new and $L.viewLastInteraction=true and nullsub($G.ess, false)=false and $G.bg=false&lt;/condition&gt;&lt;action type="string"&gt;back&lt;/action&gt;&lt;post.expressions sctype="array"&gt;&lt;post.expressions sctype="operator"&gt;$additionAction="new"&lt;/post.expressions&gt;&lt;/post.expressions&gt;&lt;rad sctype="structure"/&gt;&lt;condition.txt type="string"&gt;$L.tableAccess.new and $L.viewLastInteraction=true and nullsub($G.ess, false)=false and $G.bg=false&lt;/condition.txt&gt;&lt;unique.id type="decimal"&gt;19937&lt;/unique.id&gt;&lt;gui.sig type="decimal"&gt;3933734902&lt;/gui.sig&gt;&lt;text.sig type="decimal"&gt;560996132&lt;/text.sig&gt;&lt;sysmodcount type="decimal"&gt;3&lt;/sysmodcount&gt;&lt;sysmoduser type="string"&gt;falcon&lt;/sysmoduser&gt;&lt;sysmodtime type="dateTime"&gt;04/08/15 02:25:48&lt;/sysmodtime&gt;&lt;id type="string"&gt;cc.edit.incident_exitnew&lt;/id&gt;&lt;/instance&gt;&lt;/model&gt;';
    var doExitNew = new SCFile("displayoption");
    doExitNew.setRecord(doData);
    var ret = 0;
    system.functions.rtecall("trigger", ret, 1); //turn on trigger so displaycache refreshed
    doExitNew.doSave();
    system.functions.rtecall("trigger", ret, 0);

    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"cc.gotoincident\"");
    if (rc == RC_SUCCESS) {

        var rads = process.rad;
        var radLen = rads.length()
        for (var i = 0; i &lt; radLen; i++) {
            if ("cc.gotoincident" == rads[i].application) {
                // backup it
                backupProcess(process.process);

                if (rads[i]["pre.rad.expressions"] == null){
				  rads[i]["pre.rad.expressions"]=[];
				}
                rads[i]["pre.rad.expressions"].push(system.functions.parse("$viewLastInteraction=true", 11));
                process.doUpdate();
                addMigrationPatchRecord("Process", process, process["process"], false);
                var reportObj = {};
                reportObj.title = "The following process records are updated to provide Exit&amp;New button for the escalated interaction." + " Backups of the original process records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
                reportObj.files = ["cc.gotoincident"];
                reportObj.needManualCheck = false;
                reportObj.category="Process";
                reportObj.filename="process";
                
                SUMMARY_REPORT_OBJS.push(reportObj);

                break;
            }
        }

    }

    //provoide change category
    pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "ServiceDesk";
    var wfPhase = $("WorkflowPhase").select("workflowName=\"" + pdMigratedWorkflowName + "\" and tableName=\"incidents\" and phaseName=\"" + PHASE_NAME_INPROGRESS + "\"").uniqueResult();
    if (wfPhase) {
        wfPhase.action[0].action = "Change Category";
        wfPhase.action[0].actionName = "Change Category";
        wfPhase.action[0].actionId = "sd.action.change.category";
        wfPhase.action[0].actionCondition = system.functions.parse('$L.mode="add" and $L.tableAccess.new=true and $G.ess=false', 11);
        wfPhase.action[0].actionCondXML = "&lt;XmlCondition&gt;&lt;collection logical=\"\" negate=\"\"&gt;&lt;condition logical=\"\" negate=\"false\"&gt;&lt;operand type=\"expression\"&gt;&lt;Expression caption=\"\"&gt;\"$L.mode=&amp;quot;add&amp;quot; and $L.tableAccess.new=true and  $G.ess=false\"&lt;/Expression&gt;&lt;/operand&gt;&lt;/condition&gt;&lt;/collection&gt;&lt;/XmlCondition&gt;";
        wfPhase.action[0].actionLoc = 2;
        wfPhase.action[0].actionOption = 280;
        wfPhase.action[0].actionLock = false;
        wfPhase.action[0].actionRunAction = null;
        wfPhase.action[0].actionCondDesc = "( Expression: $L.mode=\"add\" and $L.tableAccess.new=true and  $G.ess=false)";
        wfPhase.action[0].actionMsgId = 1;
        wfPhase.doUpdate();
    }

    //using Interaction solution matching or incident solution matching
    var useSDSolutionMatching = false; // vars["$use.pd.solution.matching"] === true ? false : true;
    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"escalate.interaction\"");
    if (rc == RC_SUCCESS) {
        // backup it                
        backupProcess(process.process);

        var rads = process.rad;
        var radLen = rads.length()
        var solutiongMatchingRADFound = false;
        for (var i = 0; i &lt; radLen; i++) {
            if ("cc.incident.relate" == rads[i].application) {
                if (rads[i]["pre.rad.expressions"] == null){
				  rads[i]["pre.rad.expressions"]=[];
				}
                rads[i]["pre.rad.expressions"].push(system.functions.parse("$L.use.legacy.sd.solution.matching=" + useSDSolutionMatching + ";$isSDEscalatedIncident=true;$use.legacy.sd.solution.matching=$L.use.legacy.sd.solution.matching", 11));
                rads[i]["pre.rad.expressions"].push(system.functions.parse('if ($L.use.legacy.sd.solution.matching=false) then ($L.string="create")', 11));
                if (null != rads[i]["rad.condition"]) {
                    var strCond = system.functions.str(rads[i]["rad.condition"]);
                    rads[i]["rad.condition"] = system.functions.parse("$L.use.legacy.sd.solution.matching=true and (" + strCond + ")", 2);

                } else {
                    rads[i]["rad.condition"] = system.functions.parse("$L.use.legacy.sd.solution.matching=true", 2);
                }
                solutiongMatchingRADFound = true;
                continue;;
            }
            if (solutiongMatchingRADFound == true &amp;&amp; "wizard.run" == rads[i].application) {
                if (null != rads[i]["rad.condition"]) {
                    var strCond = system.functions.str(rads[i]["rad.condition"]);
                    rads[i]["rad.condition"] = system.functions.parse("$L.use.legacy.sd.solution.matching=true and (" + strCond + ")", 2);

                } else {
                    rads[i]["rad.condition"] = system.functions.parse("$L.use.legacy.sd.solution.matching=true", 2);
                }
                break;
            }
        }

        process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);
    }

    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"cc.first.log2\"");
    if (rc == RC_SUCCESS) {
        // backup it                
        backupProcess(process.process);

        var rads = process.rad;
        var radLen = rads.length();
        rads[radLen].application = "incident.matching";
        rads[radLen]["rad.condition"] = system.functions.parse('$use.legacy.sd.solution.matching=false and $L.action="create" and (category in $L.file~="request for change" and $exit.code.fc="normal")', 2);
        rads[radLen]["pre.rad.expressions"][0] = system.functions.parse('$L.escalateRelation="Escalated Incident"', 11);
        rads[radLen]["post.rad.expressions"][0] = system.functions.parse('if ($L.exit.match~="null" and $L.exit.match~="new") then ($link.match=true)', 11);
        rads[radLen].names = ["file", "name", "types"];
        rads[radLen].values = ["$L.file", "$L.escalateRelation", "$L.exit.match"];

        process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);
    }

    var reportObj = {};
    if (useSDSolutionMatching) {
        reportObj.title = "The following process records are updated so that non Process Designer-based solution matching is used during interaction escalation." + " Backups of the original process records (identified by the suffix \"" + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\") have been created.";

    } else {
        reportObj.title = "The following process records are updated so that Process Designer-based solution matching is used during interaction escalation." + " Backups of the original process records (identified by the suffix \"" + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\") have been created.";
    }
    reportObj.files = ["escalate.interaction", "cc.first.log2"];
    reportObj.needManualCheck = false;
    reportObj.category = "Process";
    reportObj.filename = "process";


    SUMMARY_REPORT_OBJS.push(reportObj);



    //escalate change in foreground and goes back to interaction after escalation
    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"cc.createchange\"");
    if (rc == RC_SUCCESS) {
        // backup it                var processBak = $("Process").select("process=\"" + process.process + PD_CODE_MIGRATION_DISABLE_SUFFIX + "\"").uniqueResult();
        backupProcess(process.process);

        var rads = process.rad;
        var radLen = rads.length()
        var solutiongMatchingRADFound = false;
        for (var i = 0; i &lt; radLen; i++) {
            if ("screlate" == rads[i].application) {
                if (rads[i]["pre.rad.expressions"]) {
                    rads[i]["pre.rad.expressions"].push(system.functions.parse("$escalation.wizard.call=false", 11));
                } else {
                    rads[i]["pre.rad.expressions"] = [system.functions.parse("$escalation.wizard.call=false", 11)];
                }

                break;
            }
        }

        var last = system.functions.lng(process['next.process']) + 1;
        process['next.process'][last] = "cc.gotoincident";
        process['process.condition'][last] = system.functions.parse("not  (nullsub(blank.call in $G.sm.global.environment, false)) and nullsub($L.mode.add, false) and gui()", 2);

        process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);

        var reportObj = {};
        reportObj.title = "The following process records are updated so that Change record is created in foreground during interaction escalation." + " Backups of the original process records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
        reportObj.files = ["cc.createchange"];
        reportObj.category="Process";
        reportObj.filename="process";
        
        
        reportObj.needManualCheck = false;
        SUMMARY_REPORT_OBJS.push(reportObj);
    }

    //make the save button does not exit incident during escalation
    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"im.first.save\"");
    if (rc == RC_SUCCESS) {
        // backup it                
        backupProcess(process.process);

        var rads = process.rad;
        var radLen = rads.length()

        for (var i = 0; i &lt; radLen; i++) {
            if ("us.save.relation" == rads[i].application) {
                var lenOfExp = system.functions.lng(rads[i]["post.rad.expressions"]);
                for (var j = 0; j &lt; lenOfExp; ++j) {
                    var statement = system.functions.str(rads[i]["post.rad.expressions"][j]);
                    if (statement &amp;&amp; statement.indexOf("$L.exit.when.done=true")) {
                        rads[i]["post.rad.expressions"][j] = system.functions.parse(statement.replace("$L.exit.when.done=true", " if ($L.bg=true) then ($L.exit.when.done=true)"), 11);
                        break;
                    }

                }


                break;
            }
        }


        process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);

        var reportObj = {};
        reportObj.title = "The following process records are updated so that Save button does not exit the current incident during interaction escalation." + " Backups of the original process records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
        reportObj.files = ["im.first.save"];
        reportObj.needManualCheck = false;
        reportObj.category="Process";
        reportObj.filename="process";
        
        SUMMARY_REPORT_OBJS.push(reportObj);
    }
    
    //copy neccessary expression from "cc.search.init" to "sd.search.init"
    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"sd.search.init\"");
    if (rc == RC_SUCCESS) {
        // backup it                
        backupProcess(process.process);

        var last = system.functions.lng(process['pre.expressions']) + 1;       
        process['pre.expressions'][last] = system.functions.parse('if (filename($L.file)="incidents") then ($G.ess.related=NULL;$G.ess.two=NULL)', 11);
        process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);

        var reportObj = {};       
        reportObj.title = "The following process records are updated so that necessary non-Process Designer-based search initialization code to be executed." + " Backups of the original process records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
        reportObj.files = ["sd.search.init"];
        reportObj.needManualCheck = false;
        reportObj.category="Process";
        reportObj.filename="process";
        
        SUMMARY_REPORT_OBJS.push(reportObj);
    }
    
    //clean phase for ess resubmit and copy interaction
    var process = new SCFile("Process");
    var rc = process.doSelect("process=\"cc.cloneadd\"");
    if (rc == RC_SUCCESS) {
        // backup it                
        backupProcess(process.process);

        var last = system.functions.lng(process['pre.expressions']) + 1;       
        process['pre.expressions'][last] = system.functions.parse('if (not  (null(current.phase in $L.file))) then (current.phase in $L.file=NULL;cleanup($L.wfPhase))', 11);
        process.doUpdate();
        addMigrationPatchRecord("Process", process, process["process"], false);

        var reportObj = {};       
        reportObj.title = "The following process records are updated so that correct workflow phase assigned during ESS resubmit or interaction clone." + " Backups of the original process records (identified by the suffix \""+PD_CODE_MIGRATION_DISABLE_SUFFIX+"\") have been created.";
        reportObj.files = ["cc.cloneadd"];
        reportObj.needManualCheck = false;
        reportObj.category="Process";
        reportObj.filename="process";
        
        SUMMARY_REPORT_OBJS.push(reportObj);
    }
}


function addMsgPDMpatch()
{
    var pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "Incident";
    var msgs= new SCFile("scmessage");
	var ret=msgs.doSelect('class#"local:Workflow" and message.id like "*'+pdMigratedWorkflowName+'*"');
	while(ret==RC_SUCCESS)
	{		
		addMigrationPatchRecord("scmessage",msgs,msgs["message.id"],false);
		ret=msgs.getNext();
	}
	
    pdMigratedWorkflowName = PD_CODE_MIGRATION_WF_PREFIX + "ServiceDesk";
	var msgs= new SCFile("scmessage");
	var ret=msgs.doSelect('class#"local:Workflow" and message.id like "*'+pdMigratedWorkflowName+'*"');
	while(ret==RC_SUCCESS)
	{
		addMigrationPatchRecord("scmessage",msgs,msgs["message.id"],false);
		ret=msgs.getNext();
	}
	
}

function changeSetting(settingName, settingId, settingValue) {
    printIt("Start changing setting \"" + settingName + "\" -&gt; \"" + settingId + "\" to value \"" + settingValue + "\"...", true);
    var settings = $("settings").select("name=\"" + settingName + "\"").uniqueResult();
	if(null==settings) {
	    printIt("Can't find the setting \"" + settingName + "\", ignore it!", true);
		return;
	}

	var settingIds = settings.settingId;
	var settingValues = settings.settingValue;
	if(null==settingIds) {
	    return;
	}
	for(var i=0, len=settingIds.length(); i&lt;len; i++) {
	    if(settingIds[i] === settingId) {
	        if(settingValues[i]===settingValue) {// already current value
	            printIt("The setting item's value is already current, ignore it!", true);
	            return;
	        }

	        settingValues[i] = settingValue;
	        
	        //settings.doAction("save");
	        settings.doUpdate();

	        addMigrationPatchRecord("settings", settings, settingName, false);

	        if(settingName==="Service Desk" &amp;&amp; settingId==="sd.new.entry.enabled") {
	            // add setingConfig to patch, which is updated in SL sdUtil.switchStreamlinedSD
	            var settingsConfig = new SCFile("settingsConfig");
				var rc = settingsConfig.doSelect('setting="Service Desk" and id="allow.escalate"');
				if (rc == RC_SUCCESS) {
					addMigrationPatchRecord("settingsConfig", settingsConfig, "setting:" + settingsConfig.setting + ";id:" + settingsConfig.id, false);
				}
				// add env to patch, which is updated in SL sdUtil.switchStreamlinedSD
	            var env = new SCFile("environment");
				var rc = env.doSelect('name="service desk"');
				if (rc == RC_SUCCESS) {
					addMigrationPatchRecord("environment", env, env.name, false);
				}
	        }
	        printIt("Finish changing the setting item's value!", true);
	        return;
	    }
	}
	printIt("Can't find the setting item \"" + settingId + "\", ignore it!", true);
}</script>
    <package type="string">PDFramework</package>
    <sysmodtime type="dateTime">07/16/17 17:01:42</sysmodtime>
    <sysmoduser type="string">falcon</sysmoduser>
    <sysmodcount type="decimal">0</sysmodcount>
    <prgnsystem NullValue="1" type="boolean"/>
    <sysrestricted type="boolean">true</sysrestricted>
  </record>
</recordset>
